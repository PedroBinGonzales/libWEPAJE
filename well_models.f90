MODULE well_models
!                                                          // -*- Fortran90 -*-
!/*****************************************************************************/
!/*                                                                           */
!/* (c) Copyright 2005                                                        */
!/*     Numerica Ltda                                                         */
!/*     All rights reserved.                                                  */
!/*                                                                           */
!/*     See http://numerica.com.co/ for further details.                      */
!/*                                                                           */
!/*****************************************************************************/
!/
!/ Elkin Arroyo-Negrete, Sun 05/15/2005, 14:00:00

USE invlaptrans
USE Complex_Bessel
  
IMPLICIT NONE
  
! same selected_real_kind as in calling program
INTEGER , PARAMETER, private  :: dp = SELECTED_REAL_KIND(15, 307)
REAL(dp), PARAMETER, private  :: pi = 3.14159265358979324_dp
INTEGER , PARAMETER, private  :: MAXN__ = 3000
! Symbol already defined in invlaptrans module
! INTEGER, PARAMETER, public   ::  M__ = 20

!PRIVATE
PUBLIC :: qDINF,qDINFDP,qDFracINF,qDFracINFDP,qDNFB,qDFracNFB,qDFracNFBDP,cumDFracNFB,pDVSqNFB,qDVSqNFB,CumqDVSqNFB,pDHorzNFB
PUBLIC :: pDHorzMultFracTL, qDHorzMultFracTL

! Need to add qDNFBDP
CONTAINS

! How about data type representation in Excel?
! The Double data type is 8 bytes, the Integer data type is 2 bytes, 
! and the general purpose 16 byte Variant data type can be converted
! to a 12 byte Decimal data type using the VBA conversion function CDec



!See PDF with Fortran Documentation at
!This will help us capture NaN before sending it to Excel via DLL
!http://www.math.utah.edu/~beebe/software/fortran-documentation.html
!Infinities are generated by dividing non-zero values by zero, or by binary
!operations involving an infinite value (except non-zero/infinity, which
!produces zero). NaNs are generated by dividing zero by zero, or by binary
!operations involving a NaN. The default action is that both infinities and
!NaNs propagate without interrupting execution.
!The presence of an infinity or a NaN in final results is an indication
!that something abnormal has happened. Floating-point modes can be set
!to cause interrupts when either is generated, so the offending code can be
!identified and corrected.
!NaNs have a unique property: they are the only floating-point values
!that compare unequal with themselves. This is easy to express in Fortran
!code:
!IF (x .ne. x) PRINT *,’x is a NaN’
!NaNs are useful return values for functions whose values are undefined
!for certain arguments, such as the square root or logarithm of negative
!numbers. You can generate a compile-time NaN by dividing zero by zero:
!REAL NaN
!. . .
!NaN = 0.0/0.0


!--------------------------------------------------------------------------
FUNCTION qDFracNFBDP(t,reD,xD,w,lamda,alpha_opt, tol_opt,M_opt) result(qD)
!--------------------------------------------------------------------------
!% Function computes the Dimensionless Solution of a Vertically
!% Fracture Well, No Flow Boundary Reservoir.
!% Uniform Flux Case XD=0 / Infinite Conductivity XD=0.732
!% Modify Homogeneous Solution to a dual porosity model with
!% s=u see paper
!% New Solution for Well-Test-Analisys Problems: Part 1 - Analitical
!% Considerations. Ozkan and Raghavan Eq 40
!% Elkin Arroyo-Negrete
!% 07-Sep-2012 
!% Elkin Arroyo-Negrete

  real(dp), intent(in)                  :: t
  real(dp), intent(in)                  :: reD
  real(dp), intent(in)                  :: xD
  real(dp), intent(in)                  :: w
  real(dp), intent(in)                  :: lamda
  integer,  intent(in), optional        :: M_opt    
  real(dp), intent(in), optional        :: alpha_opt
  real(dp), intent(in), optional        :: tol_opt  
  real(dp)                              :: qD
      
  complex(dp),allocatable, dimension(:) :: s
  complex(dp),allocatable, dimension(:) :: F
  real(dp), dimension(1)                :: v_t
  real(dp), dimension(1)                :: v_qD
  
  real(dp) :: alpha,tol
  integer  :: M,M2,i
  
  ! Let's make sure default values are captured 
  if(present(M_opt))then
     M =M_opt
  else
     M = M__
  end if

  if(present(alpha_opt))then
      alpha=alpha_opt
  else
      alpha=0.d0
  end if
       
  if(present(tol_opt))then
      tol=tol_opt
  else
      tol=1.d-12
  end if


  M2=2*M
  allocate(s(0:M2))
  allocate(F(0:M2))

  ! Find the points in the Laplance Space at which
  ! we need to evaluate the function prior to 
  ! numerical inversion
  ! Laplance Space Evaluation Points
  s = lsep(t,M,alpha,tol)

  !WRITE(*,*) "qDFracNFBDP(t,reD,xD,w,lamda,alpha_opt, tol_opt,M_opt)"
  !WRITE(*,*) "s ", (s,i=1,M)

  ! Evaluate function at laplace space points 
  call qDFracNFBDP_Laplance(F, s,reD,xD,w,lamda,M2)
  ! WRITE(*,*) "F ", (F,i=1,M)
  v_t(1)= t
  ! Call the laplace inverse algorithm
  call m_invlap(F, v_qD, v_t,1,alpha,tol,M)

  ! Check if we got a NA as answer. If that is the case it means
  ! we are in the infinite reD portion of the curve and as such
  ! we can call the infinte solution 
  if(v_qD(1) .NE. v_qD(1)) then
     call qDFracINFDP_Laplace(F, s,xD,w,lamda,M2)
     call m_invlap(F, v_qD, v_t,1,alpha,tol,M)
     ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
  end if
   
  ! For large values to tD algorithm becomes
  ! unstable. Let's remove stability issues by zeroing out
  ! any value of qD less than 1x10^-12
  qD    = v_qD(1)
  
  if(qD .LE. 10**(-12)) then
     qD = 0.D0
  end if

  !write(*,*) 'INSIDE qDFracNFBDP(t,reD,xD,w,lamda,alpha_opt, tol_opt,M_opt) result(qD)'
  !write(*,*) 't,reD,xD,w,lamda,alpha_opt, tol_opt,M_opt',t,reD,xD,w,lamda,alpha_opt, tol_opt,M_opt
  
  deallocate(s)
  deallocate(F)
END FUNCTION qDFracNFBDP

!-------------------------------------------------------------------
SUBROUTINE qDFracNFBDP_Laplance(qD,s,reD,xD,w,lamda,M2)
!-------------------------------------------------------------------
!% Interchange constant terminal pressure to the
!% constant terminal rate case.
!% 
!% From The Application of the Laplance Transformation to Flow 
!% Problems in Reservoirs. Van Everdingen and W Hurst
!% 1949 AIME
!% The Laplance Transformation and the superimposition theorem
!% offers the basis for interchangin the constant terminal pressure
!% to the constant terminal rate case and vise versa.
!% 
!% Elkin Arroyo-Negrete

   complex(dp), intent(in), dimension(0:M2):: s
   real(dp)   , intent(in)                 :: reD
   real(dp)   , intent(in)                 :: xD  
   real(dp)   , intent(in)                 :: w
   real(dp)   , intent(in)                 :: lamda
   integer    , intent(in)                 :: M2
   complex(dp), intent(out), dimension(0:M2) :: qD
   
   complex(dp), dimension(0:M2)            :: PD_cfracs_nfb
   integer i
   
   !WRITE(*,*) 'Inside qDFracNFBDP_Laplance(qD,s,reD,xD,w,lamda,M2)'
   !WRITE(*,*) 'reD,xD,w,lamda,M2', reD,xD,w,lamda,M2
   
   CALL pDFracNFBDP_Laplace(PD_cfracs_nfb,s,reD,xD,w,lamda,M2)
   !WRITE(*,*) 'qDFracNFBDP_Laplance(qD,s,reD,xD,w,lamda,M2)'
   !WRITE(*,*) 'After CALL pDFracNFBDP_Laplace(PD_cfracs_nfb,s,reD,xD,w,lamda,M2)'
   !WRITE(*,*) "PD_cfracs_nfb ", (PD_cfracs_nfb,i=1,M2)
  
   DO i=0,M2
      qD(i) = 1/(s(i)*s(i)*PD_cfracs_nfb(i));
   END DO
END SUBROUTINE qDFracNFBDP_Laplance

!-----------------------------------------------------------------
SUBROUTINE pDFracNFBDP_Laplace(PD_cfracs_nfb,s,reD,xD,w,lamda,M2)
!-----------------------------------------------------------------
!% Function computes the Dimensionless Solution of a Vertically
!% Fracture Well, No Flow Boundary Reservoir.
!% Uniform Flux Case XD=0 / Infinite Conductivity XD=0.732
!% Modify Homogeneous Solution with dual porosity s=u see paper
!% New Solution for Well-Test-Analisys Problems: Part 1 - Analitical
!% Considerations. Ozkan and Raghavan Eq 40
!% Elkin Arroyo-Negrete
!% 07-Sep-2012 
! Move function from Matlab to Fortran 09/16/2012

   complex(dp),intent(in), dimension(0:M2) :: s
   real(dp)   , intent(in)                 :: reD
   real(dp)   , intent(in)                 :: xD
   real(dp)   , intent(in)                 :: w
   real(dp)   , intent(in)                 :: lamda  
   integer    , intent(in)                 :: M2
   complex(dp), intent(out), dimension(0:M2) :: PD_cfracs_nfb
   
   complex(dp), dimension(0:M2):: PD_cfracs_inf
   complex(dp)                 :: x
   complex(dp)                 :: u
   complex(dp)                 :: IntBesselI0_ls !Int: Integral; ls: less (1-xD)
   complex(dp)                 :: IntBesselK0_ls 
   complex(dp)                 :: IntBesselI0_pl !Int: Integral; pl: plus (1+xD) 
   complex(dp)                 :: IntBesselK0_pl 
   integer i

   !WRITE(*,*) 'Inside pDFracNFBDP_Laplace(PD_cfracs_nfb,s,reD,xD,w,lamda,M2)'
   !WRITE(*,*) 'reD,xD,w,lamda,M2',reD,xD,w,lamda,M2

   
!% ITIKA Evaluate the integral of modified Bessel functions I0(t) and K0(t)
!% from 0 to x using series and asymptotic expansions.
DO i=0,M2

   ! % Dual Porosity Model
   u=s(i)*(w*(1-w)*s(i)+lamda ) / ((1-w)*s(i)+lamda)
   
   !write(*,*) 'pDFracNFBDP_Laplace(PD_cfracs_nfb,s,reD,xD,w,lamda,M2)'
   !write(*,*) 'u=', u
   !write(*,*) 's(i)=', s(i)
   
   x = sqrt(u)*(1-xD)
   call CITIKA(x,IntBesselI0_ls, IntBesselK0_ls)
   !write(*,*) 'IntBesselI0_ls=', IntBesselI0_ls
   !write(*,*) 'IntBesselK0_ls=', IntBesselK0_ls

   x = sqrt(u)*(1+xD)
   call CITIKA(x,IntBesselI0_pl, IntBesselK0_pl)  

   !write(*,*) 'IntBesselI0_pl=', IntBesselI0_pl
   !write(*,*) 'IntBesselK0_pl=', IntBesselK0_pl
   

   ! %Part 1 Ozkan and Raghavan Eq 40
   PD_cfracs_inf(i)=1/(2*s(i))/sqrt(u)*(IntBesselK0_ls+IntBesselK0_pl)
   ! %Part 2 Ozkan and Raghavan Eq 30
   PD_cfracs_nfb(i)=1/(2*s(i))/sqrt(u)*besselk(1,sqrt(u)*reD)/besseli(1,sqrt(u)*reD)
   PD_cfracs_nfb(i)=PD_cfracs_nfb(i)*(IntBesselI0_ls+IntBesselI0_pl)
   PD_cfracs_nfb(i) = PD_cfracs_nfb(i) + PD_cfracs_inf(i)
END DO

   !write(*,*) 'PD_cfracs_nfb(i)', PD_cfracs_nfb(i)

END SUBROUTINE pDFracNFBDP_Laplace


!---------------------------------------------------------------
FUNCTION qDFracNFB(t,reD,xD,alpha_opt, tol_opt,M_opt) result(qD)
!----------------------------------------------------------------
  real(dp), intent(in)                  :: t
  real(dp), intent(in)                  :: reD
  real(dp), intent(in)                  :: xD
  integer,  intent(in), optional        :: M_opt    
  real(dp), intent(in), optional        :: alpha_opt
  real(dp), intent(in), optional        :: tol_opt  
  real(dp)                              :: qD
      
  complex(dp),allocatable, dimension(:) :: s
  complex(dp),allocatable, dimension(:) :: F
  real(dp), dimension(1)                :: v_t
  real(dp), dimension(1)                :: v_qD
  
  real(dp) :: alpha,tol,rD
  integer  :: M,M2
  
  ! Let's make sure default values are captured 
  if(present(M_opt))then
     M =M_opt
  else
     M = M__
  end if

  if(present(alpha_opt))then
      alpha=alpha_opt
  else
      alpha=0.d0
  end if
       
  if(present(tol_opt))then
      tol=tol_opt
  else
      tol=1.d-12
  end if


  ! Correlation below shows that for a given tD an stable value of rD
  ! has to be greater than  exp(0.5*log(tD)+2.0993) otherwise it will produce a NaN
  ! We should then find the rD that will produce the right value of qD and will not have
  ! stability issues with the algorithm

  ! ln(tD)=0.5*ln(rD)+4.7793
  ! ln(rD)= 0.5ln(tD) + 4.8337 "From Single Well No Fracture"

  ! ln(rD) = 1.9998ln(tD) - 9.5576
  ! ln(tD) = 2.0ln(rD) - 9.6661 "From Single Well No Fracture"


  ! /share/homes/earroyo/Funes/Works/CourseWork/TAMU/DataIntegration/FractureWell/HOOG
  ! See file X:\FractureWell\HOOG\InfiniteCondFracWell.xls at Funes
  ! Programed by Rafael Joaquin Arroyo-Cruz
  ! Waiting on PBS Kids . org

  if(t .LE. exp(2.D0*log(reD)- 9.5576D0) ) then
       !erro=getcwd(CURDIR)
       !FILENAME = TRIM(CURDIR)//'\qDNFBDLL_Validation.txt'
       !open (unit = 101, file = FILENAME)
       !write(101,*) 'Function Was Call From VBA'
       !write(101,*) 'tD=',tD, ' rD=',R
       !tD_vali = exp(2.0D0*log(rD)- 9.6661D0)
       !write(101,*) 'Since tD=', tD, ' is .LE. than exp(2.0*log(rD) - 9.6661D0)', tD_vali 
       !write(101,*) 'Change rD exp(0.5*log(tD)+ 4.8337D0 - 0.1D0) to', exp(0.5*log(tD)+ 4.8337D0 - 0.1D0)
       !close(101)

       rD = exp(0.5D0*log(t)+ 4.7793D0 - 0.13D0)  
       if(rD<1.D0) then
          rD = 1.001D0
       end if
  else
       rD = reD
  end if


  M2=2*M
  allocate(s(0:M2))
  allocate(F(0:M2))
  ! Find the points in the Laplance Space at which
  ! we need to evaluate the function prior to 
  ! numerical inversion
  ! Laplance Space Evaluation Points
  s = lsep(t,M,alpha,tol)

  ! Evaluate function at laplace space points 
  call qDFracNFB_Laplance(F, s,rD,xD,M2)
  v_t(1)= t

  ! Call the laplace inverse algorithm
  call m_invlap(F, v_qD, v_t,1,alpha,tol,M)

  ! Check if we got a NA as answer. If that is the case it means
  ! we are in the infinite reD portion of the curve and as such
  ! we can call the infinte solution 
  if(v_qD(1) .NE. v_qD(1)) then
     call qDFracINF_Laplace(F,s,xD,M2)
     call m_invlap(F, v_qD, v_t,1,alpha,tol,M)
     ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
  end if



  ! For large values to tD algorithm becomes
  ! unstable. Let's remove stability issues by zeroing out
  ! any value of qD less than 1x10^-12
  qD    = v_qD(1)
  if(qD .LE. 10**(-12)) then
     qD = 0.D0
  end if
  
  deallocate(s)
  deallocate(F)  
END FUNCTION qDFracNFB

!---------------------------------------------------------------
FUNCTION cumDFracNFB(t,reD,xD,alpha_opt, tol_opt,M_opt) result(qD)
!----------------------------------------------------------------
! Compute the volume of well in a single layer vertically
! fractured reservoir
! 
!   QD = \int{qD,0,t}
!
!   QD = qD/s   
!
! In Lapace space multipy times s is equivalent to integrate with
! respect to time
!
 
  real(dp), intent(in)                  :: t
  real(dp), intent(in)                  :: reD
  real(dp), intent(in)                  :: xD
  integer,  intent(in), optional        :: M_opt    
  real(dp), intent(in), optional        :: alpha_opt
  real(dp), intent(in), optional        :: tol_opt  
  real(dp)                              :: qD
      
  complex(dp),allocatable, dimension(:) :: s
  complex(dp),allocatable, dimension(:) :: F
  real(dp), dimension(1)                :: v_t
  real(dp), dimension(1)                :: v_qD
  
  real(dp) :: alpha,tol,rD
  integer  :: M,M2,i
  
  ! Let's make sure default values are captured 
  if(present(M_opt))then
     M =M_opt
  else
     M = M__
  end if

  if(present(alpha_opt))then
      alpha=alpha_opt
  else
      alpha=0.d0
  end if
       
  if(present(tol_opt))then
      tol=tol_opt
  else
      tol=1.d-12
  end if

  M2=2*M
  allocate(s(0:M2))
  allocate(F(0:M2))
  ! Laplance Space Evaluation Points
  s = lsep(t,M,alpha,tol)
  
  ! Evaluate function at laplace space points 
  ! CALL pDFracNFB_Laplace(F, s,reD,xD,M2)
  !      pDNFB_Laplace(pD,s,reD,r, M2)
  ! CALL pDNFB_Laplace(F, s,reD,1.0D0,M2)
  !    CumqDNFB_Laplace(qD, s,R,M2)
  CALL CumqDNFB_Laplace(F, s,reD,M2)
  ! Now integrate with respect to time so we can find volume
  ! q=Q*s
  !DO i=0,M2
  !   F(i)=1/(s(i)*s(i)*s(i)*F(i))
  !END DO
  ! CALL qDFracNFB_Laplance(F, s,reD,xD,M2)
  
  v_t(1)= t  
  ! Call the laplace inverse algorithm
  call m_invlap(F, v_qD, v_t,1,alpha,tol,M)

  ! Check if we got a NA as answer. If that is the case it means
  ! we are in the infinite reD portion of the curve and as such
  ! we can call the infinte solution 
  !if(v_qD(1) .NE. v_qD(1)) then
  !   call pDFracINF_Laplace(F,s,xD,M2)
  !   DO i=0,M2
  !     F(i)=1/(F(i)*s(i)*s(i)*s(i))
  !   END DO
  !   call m_invlap(F, v_qD, v_t,1,alpha,tol,M)
  !end if

  ! For large values to tD algorithm becomes
  ! unstable. Let's remove stability issues by zeroing out
  ! any value of qD less than 1x10^-12
  qD    = v_qD(1)
  !if(qD .LE. 10**(-12)) then
  !   qD = 0.D0
  !end if
  
  deallocate(s)
  deallocate(F)  
END FUNCTION cumDFracNFB



!-------------------------------------------------------------------
SUBROUTINE qDFracNFB_Laplance(qD,s,reD,xD,M2)
!-------------------------------------------------------------------
!% Interchange constant terminal pressure to the
!% constant terminal rate case.
!% 
!% From The Application of the Laplance Transformation to Flow 
!% Problems in Reservoirs. Van Everdingen and W Hurst
!% 1949 AIME
!% The Laplance Transformation and the superimposition theorem
!% offers the basis for interchangin the constant terminal pressure
!% to the constant terminal rate case and vise versa.
!% 
!% Elkin Arroyo-Negrete

   complex(dp), intent(in), dimension(0:M2):: s
   real(dp)   , intent(in)                 :: reD
   real(dp)   , intent(in)                 :: xD  
   integer    , intent(in)                 :: M2
   complex(dp), intent(out), dimension(0:M2) :: qD
   
   complex(dp), dimension(0:M2)            :: PD_cfracs_nfb
   integer i
      
   CALL pDFracNFB_Laplace(PD_cfracs_nfb,s,reD,xD,M2)
   DO i=0,M2
      qD(i) = 1/(s(i)*s(i)*PD_cfracs_nfb(i));
   END DO
END SUBROUTINE qDFracNFB_Laplance

!-------------------------------------------------------------
SUBROUTINE pDFracNFB_Laplace(PD_cfracs_nfb,s,reD,xD,M2)
!-------------------------------------------------------------
!% Function computes the Dimensionless Solution of a Vertically
!% Fracture Well, No Flow Boundary Reservoir.
!% Uniform Flux Case XD=0 / Infinite Conductivity XD=0.732
!% Elkin Arroyo-Negrete
!% 06-Sep-2012 
! Move function from Matlab to Fortran 09/16/2012

   complex(dp),intent(in), dimension(0:M2) :: s
   real(dp)   , intent(in)                 :: reD
   real(dp)   , intent(in)                 :: xD  
   integer    , intent(in)                 :: M2
   complex(dp), intent(out), dimension(0:M2) :: PD_cfracs_nfb
   
   complex(dp), dimension(0:M2):: PD_cfracs_inf
   complex(dp)                 :: x
   complex(dp)                 :: IntBesselI0_ls !Int: Integral; ls: less (1-xD)
   complex(dp)                 :: IntBesselK0_ls 
   complex(dp)                 :: IntBesselI0_pl !Int: Integral; pl: plus (1+xD) 
   complex(dp)                 :: IntBesselK0_pl 
   integer i
   
!% ITIKA Evaluate the integral of modified Bessel functions I0(t) and K0(t)
!% from 0 to x using series and asymptotic expansions.
DO i=0,M2
   x = sqrt(s(i))*(1-xD);
   call CITIKA(x,IntBesselI0_ls, IntBesselK0_ls);
   x = sqrt(s(i))*(1+xD);
   call CITIKA(x,IntBesselI0_pl, IntBesselK0_pl);  
   PD_cfracs_inf(i)=1/(2*s(i))/sqrt(s(i))*(IntBesselK0_ls+IntBesselK0_pl)
   PD_cfracs_nfb(i)=1/(2*s(i))/sqrt(s(i))*besselk(1,sqrt(s(i))*reD)/besseli(1,sqrt(s(i))*reD)
   PD_cfracs_nfb(i)=PD_cfracs_nfb(i)*(IntBesselI0_ls+IntBesselI0_pl)
   PD_cfracs_nfb(i) = PD_cfracs_nfb(i) + PD_cfracs_inf(i)
END DO
END SUBROUTINE pDFracNFB_Laplace

!---------------------------------------------------------------
FUNCTION qDFracINF(t,xD,alpha_opt, tol_opt,M_opt) result(qD)
!----------------------------------------------------------------
  real(dp), intent(in)                  :: t
  real(dp), intent(in)                  :: xD
  integer,  intent(in), optional        :: M_opt    
  real(dp), intent(in), optional        :: alpha_opt
  real(dp), intent(in), optional        :: tol_opt  
  real(dp)                              :: qD
      
  complex(dp),allocatable, dimension(:) :: s
  complex(dp),allocatable, dimension(:) :: F
  real(dp), dimension(1)                :: v_t
  real(dp), dimension(1)                :: v_qD
  
  real(dp) :: alpha,tol,rD
  integer  :: M,M2
  
  ! Let's make sure default values are captured 
  if(present(M_opt))then
     M =M_opt
  else
     M = M__
  end if

  if(present(alpha_opt))then
      alpha=alpha_opt
  else
      alpha=0.d0
  end if
       
  if(present(tol_opt))then
      tol=tol_opt
  else
      tol=1.d-12
  end if

  M2=2*M
  allocate(s(0:M2))
  allocate(F(0:M2))
  ! Find the points in the Laplance Space at which
  ! we need to evaluate the function prior to 
  ! numerical inversion
  ! Laplace Space Evaluation Points
  s = lsep(t,M,alpha,tol)

  ! Evaluate function at laplace space points 
  call qDFracINF_Laplace(F,s,xD,M2)
  v_t(1)= t

  ! Call the laplace inverse algorithm
  call m_invlap(F, v_qD, v_t,1,alpha,tol,M)

  ! For large values to tD algorithm becomes
  ! unstable. Let's remove stability issues by zeroing out
  ! any value of qD less than 1x10^-12
  qD    = v_qD(1)
  if(qD .LE. 10**(-12)) then
     qD = 0.D0
  end if
  
  deallocate(s)
  deallocate(F)  
END FUNCTION qDFracINF


!-------------------------------------------------------------------
SUBROUTINE qDFracINF_Laplace(qD,s,xD,M2)
!-------------------------------------------------------------------
!% Interchange constant terminal pressure to the
!% constant terminal rate case.
!% 
!% From The Application of the Laplance Transformation to Flow 
!% Problems in Reservoirs. Van Everdingen and W Hurst
!% 1949 AIME
!% The Laplance Transformation and the superimposition theorem
!% offers the basis for interchangin the constant terminal pressure
!% to the constant terminal rate case and vise versa.
!% 
!% Elkin Arroyo-Negrete

   complex(dp), intent(in), dimension(0:M2):: s
   real(dp)   , intent(in)                 :: xD  
   integer    , intent(in)                 :: M2
   complex(dp), intent(out), dimension(0:M2) :: qD
   
   complex(dp), dimension(0:M2)            :: PD_cfracs_inf
   integer i
      
   CALL pDFracINF_Laplace(PD_cfracs_inf,s,xD,M2)
   DO i=0,M2
      qD(i) = 1/(s(i)*s(i)*PD_cfracs_inf(i));
   END DO
END SUBROUTINE qDFracINF_Laplace

!-------------------------------------------------------------
SUBROUTINE pDFracINF_Laplace(PD_cfracs_inf,s,xD,M2)
!-------------------------------------------------------------
!% Function computes the Dimensionless Solution of a Vertically
!% Fracture Well, Infinite Acting Reservoir Reservoir.
!% Uniform Flux Case XD=0 / Infinite Conductivity XD=0.732
!% Elkin Arroyo-Negrete
!% 06-Sep-2012 
! See paper: 
! New Solution for Well-Test-Analisys Problems: Part 1 - 
! Analitical Considerations. SPE Formation Evaluation 1991
! Erdal Ozkan and Rajagopal Raghavan, page 340 Table
! Solution for wells in Infinte Reservoirs 
! Fractured Well. Also see more computational efficient
! re-arrangement of same equation at Page 362 Equation 40


   complex(dp),intent(in), dimension(0:M2) :: s
   real(dp)   , intent(in)                 :: xD  
   integer    , intent(in)                 :: M2
   complex(dp), intent(out), dimension(0:M2) :: PD_cfracs_inf
   
   complex(dp)                 :: x
   complex(dp)                 :: IntBesselI0_ls !Int: Integral; ls: less (1-xD)
   complex(dp)                 :: IntBesselK0_ls 
   complex(dp)                 :: IntBesselI0_pl !Int: Integral; pl: plus (1+xD) 
   complex(dp)                 :: IntBesselK0_pl 
   integer i
   
!% ITIKA Evaluate the integral of modified Bessel functions I0(t) and K0(t)
!% from 0 to x using series and asymptotic expansions.
DO i=0,M2
   x = sqrt(s(i))*(1-xD);
   call CITIKA(x,IntBesselI0_ls, IntBesselK0_ls);
   x = sqrt(s(i))*(1+xD);
   call CITIKA(x,IntBesselI0_pl, IntBesselK0_pl);  
   PD_cfracs_inf(i)=1/(2*s(i))/sqrt(s(i))*(IntBesselK0_ls+IntBesselK0_pl)
END DO
END SUBROUTINE pDFracINF_Laplace

!---------------------------------------------------------------
FUNCTION qDFracINFDP(t,xD,w,lamda,alpha_opt, tol_opt,M_opt) result(qD)
!----------------------------------------------------------------
  real(dp), intent(in)                  :: t
  real(dp), intent(in)                  :: xD
  real(dp), intent(in)                  :: w
  real(dp), intent(in)                  :: lamda
  integer,  intent(in), optional        :: M_opt    
  real(dp), intent(in), optional        :: alpha_opt
  real(dp), intent(in), optional        :: tol_opt  
  real(dp)                              :: qD
      
  complex(dp),allocatable, dimension(:) :: s
  complex(dp),allocatable, dimension(:) :: F
  real(dp), dimension(1)                :: v_t
  real(dp), dimension(1)                :: v_qD
  
  real(dp) :: alpha,tol,rD
  integer  :: M,M2
  
  ! Let's make sure default values are captured 
  if(present(M_opt))then
     M =M_opt
  else
     M = M__
  end if

  if(present(alpha_opt))then
      alpha=alpha_opt
  else
      alpha=0.d0
  end if
       
  if(present(tol_opt))then
      tol=tol_opt
  else
      tol=1.d-12
  end if

  M2=2*M
  allocate(s(0:M2))
  allocate(F(0:M2))
  ! Find the points in the Laplance Space at which
  ! we need to evaluate the function prior to 
  ! numerical inversion
  ! Laplace Space Evaluation Points
  s = lsep(t,M,alpha,tol)

  ! Evaluate function at laplace space points 
  call qDFracINFDP_Laplace(F,s,xD,w,lamda,M2)
  v_t(1)= t

  ! Call the laplace inverse algorithm
  call m_invlap(F, v_qD, v_t,1,alpha,tol,M)

  ! For large values to tD algorithm becomes
  ! unstable. Let's remove stability issues by zeroing out
  ! any value of qD less than 1x10^-12
  qD    = v_qD(1)
  if(qD .LE. 10**(-12)) then
     qD = 0.D0
  end if
  
  deallocate(s)
  deallocate(F)  
END FUNCTION qDFracINFDP

!-------------------------------------------------------------------
SUBROUTINE qDFracINFDP_Laplace(qD,s,xD,w,lamda,M2)
!-------------------------------------------------------------------
!% Interchange constant terminal pressure to the
!% constant terminal rate case.
!% 
!% From The Application of the Laplance Transformation to Flow 
!% Problems in Reservoirs. Van Everdingen and W Hurst
!% 1949 AIME
!% The Laplance Transformation and the superimposition theorem
!% offers the basis for interchangin the constant terminal pressure
!% to the constant terminal rate case and vise versa.
!% 
!% Elkin Arroyo-Negrete

   complex(dp), intent(in), dimension(0:M2):: s
   real(dp)   , intent(in)                 :: xD
   real(dp)   , intent(in)                 :: w
   real(dp)   , intent(in)                 :: lamda     
   integer    , intent(in)                 :: M2
   complex(dp), intent(out), dimension(0:M2) :: qD
   
   complex(dp), dimension(0:M2)            :: PD_cfracs_inf
   integer i
      
   CALL pDFracINFDP_Laplace(PD_cfracs_inf,s,xD,w,lamda,M2)
   DO i=0,M2
      qD(i) = 1/(s(i)*s(i)*PD_cfracs_inf(i));
   END DO
END SUBROUTINE qDFracINFDP_Laplace

!-------------------------------------------------------------
SUBROUTINE pDFracINFDP_Laplace(PD_cfracs_inf,s,xD,w,lamda,M2)
!-------------------------------------------------------------
!% Function computes the Dimensionless Solution of a Vertically
!% Fracture Well, Infinite Acting Reservoir Reservoir.
!% Uniform Flux Case XD=0 / Infinite Conductivity XD=0.732
!% Elkin Arroyo-Negrete
!% 06-Sep-2012 
! See paper: 
! New Solution for Well-Test-Analisys Problems: Part 1 - 
! Analitical Considerations. SPE Formation Evaluation 1991
! Erdal Ozkan and Rajagopal Raghavan, page 340 Table
! Solution for wells in Infinte Reservoirs 
! Fractured Well. Also see more computational efficient
! re-arrangement of same equation at Page 362 Equation 40
!% Modify Homogeneous Solution with dual porosity s=u see paper
!% New Solution for Well-Test-Analisys Problems: Part 1 - Analitical
!% Considerations. Ozkan and Raghavan Eq 40
!% Elkin Arroyo-Negrete
!% 07-Sep-2012 


   complex(dp),intent(in), dimension(0:M2) :: s
   real(dp)   , intent(in)                 :: xD
   real(dp)   , intent(in)                 :: w
   real(dp)   , intent(in)                 :: lamda
     
   integer    , intent(in)                 :: M2
   complex(dp), intent(out), dimension(0:M2) :: PD_cfracs_inf
   
   complex(dp)                 :: x
   complex(dp)                 :: u
   complex(dp)                 :: IntBesselI0_ls !Int: Integral; ls: less (1-xD)
   complex(dp)                 :: IntBesselK0_ls 
   complex(dp)                 :: IntBesselI0_pl !Int: Integral; pl: plus (1+xD) 
   complex(dp)                 :: IntBesselK0_pl 
   integer i
   
!% ITIKA Evaluate the integral of modified Bessel functions I0(t) and K0(t)
!% from 0 to x using series and asymptotic expansions.
DO i=0,M2
   ! % Dual Porosity Model
   u=s(i)*(w*(1-w)*s(i)+lamda ) / ((1-w)*s(i)+lamda)
   x = sqrt(u)*(1-xD)
   call CITIKA(x,IntBesselI0_ls, IntBesselK0_ls)
   x = sqrt(u)*(1+xD)
   call CITIKA(x,IntBesselI0_pl, IntBesselK0_pl) 
   ! %Part 1 Ozkan and Raghavan Eq 40 
   PD_cfracs_inf(i)=1/(2*s(i))/sqrt(u)*(IntBesselK0_ls+IntBesselK0_pl)
END DO
END SUBROUTINE pDFracINFDP_Laplace

!-----------------------------------------------  
SUBROUTINE qDNFB_Laplace(qD, s,R,M2)
!-----------------------------------------------
!% This function computes the dimensionless pressure
!% solution in the Laplance space for the radial 
!% difusivity equation on a finite wellbore with 
!% constant pressue in an finite-acting reservoir.
!% Having no flow at the boundary of the reservoir 
!% See Paper:
!% The Application of the Laplance Transformation to flow
!% problems in reservoir
!% Van Everding and Hurst

   complex(dp),intent(in), dimension(0:M2) :: s
   real(dp)   , intent(in)              :: R
   integer    , intent(in)              :: M2
   complex(dp), intent(out), dimension(0:M2) :: qD
   complex(dp) :: numerator, denominator, p
   integer i

   do i=0,M2
      p = s(i)
      ! Notice the similarity with equation VIII-3. Since we are interested at wellbore rate then
      ! in equation VIII-3 we make r=1 and change sing in numerator
      numerator = (besseli(1,R*sqrt(p))*besselk(1,sqrt(p)) - besselk(1,R*sqrt(p))*besseli(1,sqrt(p)))
      denominator = sqrt(p)*( besselk(1,R*sqrt(p))*besseli(0,  sqrt(p)) + besseli(1,R*sqrt(p))*besselk(0,  sqrt(p)))
      qD(i) = (numerator) / (denominator)
   end do
END SUBROUTINE

!-----------------------------------------------  
SUBROUTINE CumqDNFB_Laplace(qD, s,R,M2)
!-----------------------------------------------
!% This function computes the dimensionless pressure
!% solution in the Laplance space for the radial 
!% difusivity equation on a finite wellbore with 
!% constant pressue in an finite-acting reservoir.
!% Having no flow at the boundary of the reservoir 
!% See Paper:
!% The Application of the Laplance Transformation to flow
!% problems in reservoir
!% Van Everding and Hurst

   complex(dp),intent(in), dimension(0:M2) :: s
   real(dp)   , intent(in)              :: R
   integer    , intent(in)              :: M2
   complex(dp), intent(out), dimension(0:M2) :: qD
   complex(dp) :: numerator, denominator, p
   integer i

   do i=0,M2
      p = s(i)
      ! Notice the similarity with equation VIII-3. Since we are interested at wellbore rate then
      ! in equation VIII-3 we make r=1 and change sing in numerator
      numerator = (besseli(1,R*sqrt(p))*besselk(1,sqrt(p)) - besselk(1,R*sqrt(p))*besseli(1,sqrt(p)))
      denominator = p**(1.5d0)*( besselk(1,R*sqrt(p))*besseli(0,  sqrt(p)) + besseli(1,R*sqrt(p))*besselk(0,  sqrt(p)))
      qD(i) = (numerator) / (denominator)
   end do
END SUBROUTINE



!--------------------------------------------------------
FUNCTION qDNFB(tD,R, alpha_opt, tol_opt, M_opt) result(qD)
!---------------------------------------------------------
  real(dp), intent(in)                  :: tD
  real(dp), intent(in)                  :: R
  integer,  intent(in), optional        :: M_opt    
  real(dp), intent(in), optional        :: alpha_opt
  real(dp), intent(in), optional        :: tol_opt  
  real(dp)                              :: qD
      
  complex(dp),allocatable, dimension(:) :: s
  complex(dp),allocatable, dimension(:) :: F
  real(dp), dimension(1)                :: v_t
  real(dp), dimension(1)                :: v_qD
  real(dp)                              :: rD
  
  real(dp) :: alpha,tol
  integer  :: M,M2,i
  
!  CHARACTER (LEN=256) FILENAME
!  CHARACTER (LEN=256)::CURDIR
!  INTEGER            ::erro

  
  ! Let's make sure default values are captured 
  if(present(M_opt))then
     M =M_opt
  else
     M = M__
  end if

  if(present(alpha_opt))then
      alpha=alpha_opt
  else
      alpha=0.d0
  end if
       
  if(present(tol_opt))then
      tol=tol_opt
  else
      tol=1.d-12
  end if

  M2=2*M
  allocate(s(0:M2))
  allocate(F(0:M2))

  ! One can clealy see that for tD minor than 1.0 all curves converge 
  ! to same value. Nevertheless there are stability issues as R becomes
  ! greater than 5. Force calculation to be R=5 if tD is less than 1.0

  ! Correlation below shows that for a given tD an stable value of rD
  ! has to be greater than  exp(0.5*log(tD)+4.8337) otherwise it will produce a NaN
  ! We should then find the rD that will produce the right value of qD and will not have
  ! stability issues with the algorithm
  ! ln(rD)= 0.5ln(tD) + 4.8337
  ! ln(tD) = 2.0ln(rD) - 9.6661
  ! See file X:\FractureWell\HOOG\Fetkovich_full.xls at Funes
  ! /share/homes/earroyo/Funes/Works/CourseWork/TAMU/DataIntegration/FractureWell/HOOG

  
  if(tD .LE. exp(2.D0*log(R)- 9.6661D0) ) then
       !erro=getcwd(CURDIR)
       !FILENAME = TRIM(CURDIR)//'\qDNFBDLL_Validation.txt'
       !open (unit = 101, file = FILENAME)
       !write(101,*) 'Function Was Call From VBA'
       !write(101,*) 'tD=',tD, ' rD=',R
       !tD_vali = exp(2.0D0*log(rD)- 9.6661D0)
       !write(101,*) 'Since tD=', tD, ' is .LE. than exp(2.0*log(rD) - 9.6661D0)', tD_vali 
       !write(101,*) 'Change rD exp(0.5*log(tD)+ 4.8337D0 - 0.1D0) to', exp(0.5*log(tD)+ 4.8337D0 - 0.1D0)
       !close(101)

       rD = exp(0.5D0*log(tD)+ 4.8337D0 - 0.13D0)  
       if(rD<1.D0) then
          rD = 1.001D0
       end if
  else
       rD = R
  end if


  ! Find the points in the Laplace Space at which
  ! we need to evaluate the function prior to 
  ! numerical inversion
  ! Laplace Space Evaluation Points
  s = lsep(tD,M,alpha,tol)
  
  call qDNFB_Laplace(F, s,rD,M2)

  !write(*,*)  "Inside FUNCTION qDNFB(tD,R, alpha_opt, tol_opt, M_opt) result(qD)"
  !DO i=0,M2
  !   write(*,*) 'i=',i, 'F:  ', F(i)
  !   write(*,*) 'i=',i, 's:  ', s(i)
  !END DO
  !write(*,*) 'tD: ', tD
  !write(*,*) 'reD:', rD
  !write(*,*) 'M2: ', M2
  
  v_t(1)= tD
  call m_invlap(F, v_qD, v_t,1,alpha,tol,M) 
  
  ! For large values to tD algorithm becomes
  ! unstable. Let's remove stability issues by zeroing out
  ! any value of qD less than 1x10^-12
  qD    = v_qD(1)
  if(qD .LE. 10**(-12)) then
     qD = 0.D0
  end if
  
  deallocate(s)
  deallocate(F)  
END FUNCTION


!--------------------------------------------------------------------------
SUBROUTINE pDNFB_Laplace(pD,s,reD,r,M2)
!--------------------------------------------------------------------------
! function [qD]=qDCPInf(s,rD)
!% Diffusivity equation solution in laplance space for a radial flow with
!% constant rate inner boundary condition. Constant pressure
!% outler boundary condition and initial condition of pressure pi
!% Radial flow finite wellbore with constant rate production
!% in an infinite-acting reservoir.
!% In dimension less parameters
!% s  : Laplace variable
!% rD : Dimension less radius Allows evaluation of pressure at any point
!% 
!% '=======================================================================
!% 'Reference: paper "The Application of the Laplace Transformation to Flow
!% 'Problems in Reservoirs," Petroleum Transactions, AIME, T.P. 2732.
!% 'Van Everdingen and Hurst 
!% '
!% 'Definition of variables
!% '
!% '   s = Laplace space variable
!% '   Lqd = Laplace transform of the rate solution (constant pressure)
!% '   r = dimensionless distance (radius) = rw/rw; think on it as 1
!          or at any other value in the reservoir r=ri/rw
!% '   Note: r = 1 gives the solution at the wellbore
!      reD = dimensionless reservoir size, think on it as reD
!      reD = re/rwa
!% '
!% '=======================================================================
!
! Solution below allows us to plot the pressure field at any point in 2D space
! at any point in time. Some examples below
!
! Now let's consider the case were we want to plot the pressure field in the
! reservoir, in this case we need to go over all reservoir domain r=ri/rw
! having fix reD=re/rw
! Pressure field -> pD(reD=cte,r=ri/rw)|i=1 to reD
! From the prespective of qD we tipically are only interested to know the 
! rate at wellbore therefore this function should normally be called with
! r=1.D0 when called from qD
! Notice that what changes in the Fetkovich plot is reD, this can be interpreted
! as qD for different reservoir sizes. Now since this is a ratio, then the 
! reservoir size is a relative concept. One can think of it as 1) a fix reservoir
! size (re) and increasing values of rw or as 2) a fixed rw and increasing values of
! re. Fetkovich amazing thinking was to inteprete solution as 1)
! Elkin Arroyo-Negrete, 10/08/2012

   complex(dp), intent(in), dimension(0:M2)  :: s
   real(dp)   , intent(in)                   :: reD ! use reD to specify the size of the reservoir
   real(dp)   , intent(in)                   :: r   ! Use 1 to evaluate at wellbore
   integer    , intent(in)                   :: M2
   complex(dp), intent(out), dimension(0:M2) :: pD
   integer i

   do i=0,M2
      !% Equation VII-3 Page 317
      pD(i) = besselk(1,reD*sqrt(s(i)))*besseli(0,r*sqrt(s(i)))
      pD(i) = pD(i) + besseli(1,reD*sqrt(s(i)))*besselk(0,r*sqrt(s(i)))
      pD(i) = pD(i)/(besselk(1,reD*sqrt(s(i)))*besseli(0,sqrt(s(i)))+besseli(1,reD*sqrt(s(i)))*besselk(0,sqrt(s(i))))
      pD(i) = pD(i)/s(i)
   end do
END SUBROUTINE pDNFB_Laplace


!--------------------------------------------------------
FUNCTION qDINF(tD,reD_opt,alpha_opt, tol_opt, M_opt) result(qD)
!---------------------------------------------------------
! Solution of the Difusivity Equation for a wellbore
! in a infinite reservoir, homogenous formation
! with a constant pressure drawdonw at wellbore
!
!% 'Definition of variables
!% '
!% '   s = Laplace space variable
!% '   rD = dimensionless distance (radius) = r/rw;
!% '   Note: rD = 1 gives the solution at the wellbore

  real(dp), intent(in)                  :: tD
  real(dp), intent(in), optional        :: reD_opt
  real(dp), intent(in), optional        :: alpha_opt
  real(dp), intent(in), optional        :: tol_opt
  integer,  intent(in), optional        :: M_opt        
  real(dp)                              :: qD
      
  complex(dp),allocatable, dimension(:) :: s
  complex(dp),allocatable, dimension(:) :: F
  real(dp), dimension(1)                :: v_t
  real(dp), dimension(1)                :: v_qD
  real(dp)                              :: reD

  real(dp) :: alpha,tol
  integer  :: M,M2,i
  
  ! Let's make sure default values are captured 
  ! rD = dimensionless distance (radius) = r/rw;
  ! Note: reD = 1 gives the solution at the wellbore
  if(present(reD_opt))then
     reD = reD_opt
  else
     reD = 1.0D0
  end if
  
  if(present(M_opt))then
     M =M_opt
  else
     M = M__
  end if

  if(present(alpha_opt))then
      alpha=alpha_opt
  else
      alpha=0.d0
  end if
       
  if(present(tol_opt))then
      tol=tol_opt
  else
      tol=1.d-12
  end if

  !WRITE(*,*) 'INSIDE FUNCTION qDINF(tD,reD_opt,alpha_opt, tol_opt, M_opt) result(qD)'
  !WRITE(*,*) 'tD,reD,alpha,tol,M', tD,reD,alpha,tol,M

  M2=2*M
  allocate(s(0:M2))
  allocate(F(0:M2))

  ! Find the points in the Laplace Space at which
  ! we need to evaluate the function prior to 
  ! numerical inversion
  ! Laplace Space Evaluation Points
  s = lsep(tD,M,alpha,tol)

  ! Now call Well Model that we want to solve for
  call qDINF_Laplace(F, s, reD,M2)

  !write(*,*)  "Inside FUNCTION qDINF(tD,reD_opt,alpha_opt, tol_opt, M_opt) result(qD)"
  !DO i=0,M2
  !   write(*,*) 'i=',i, 'F:  ', F(i)
  !   write(*,*) 'i=',i, 's:  ', s(i)
  !END DO
  !write(*,*) 'tD: ', tD
  !write(*,*) 'reD:', reD
  !write(*,*) 'M2: ', M2

  v_t(1)= tD
  ! Now perform a numerical inversion from Laplace Space
  ! to real time
  call m_invlap(F, v_qD, v_t,1,alpha,tol,M) 
  
  ! For large values to tD algorithm becomes
  ! unstable. Let's remove stability issues by zeroing out
  ! any value of qD less than 1x10^-12
  qD    = v_qD(1)
  
  !write(*,*) 'Calling invere Laplace with'
  !write(*,*) 'tD,1,alpha,tol,M',v_t(1),1,alpha,tol,M 
  !write(*,*) 'After m_invlap qD=',qD,v_qD(1)
  
  if(qD .LE. 10**(-12)) then
     qD = 0.D0
  end if
  
  deallocate(s)
  deallocate(F) 
END FUNCTION


!--------------------------------------------------------------------------
SUBROUTINE pDINF_Laplace(pD,s,reD,M2)
!--------------------------------------------------------------------------
! function [qD]=qDCPInf(s,rD)
!% Diffusivity equation solution in laplance space for a radial flow with
!% constant rate inner boundary condition. Constant pressure
!% outler boundary condition and initial condition of pressure pi
!% Radial flow finite wellbore with constant rate production
!% in an infinite-acting reservoir.
!% In dimension less parameters
!% s  : Laplace variable
!% rD : Dimension less radius Allows evaluation of pressure at any point
!% 
!% '=======================================================================
!% 'Reference: paper "The Application of the Laplace Transformation to Flow
!% 'Problems in Reservoirs," Petroleum Transactions, AIME, T.P. 2732.
!% 'Van Everdingen and Hurst 
!% '
!% 'Definition of variables
!% '
!% '   s = Laplace space variable
!% '   Lqd = Laplace transform of the rate solution (constant pressure)
!% '   rD = dimensionless distance (radius) = r/rw;
!% '       Note: rd = 1 gives the solution at the wellbore
!% '
!% '=======================================================================

   complex(dp), intent(in), dimension(0:M2)  :: s
   real(dp)   , intent(in)                   :: reD
   integer    , intent(in)                   :: M2
   complex(dp), intent(out), dimension(0:M2) :: pD
   integer i

   do i=0,M2
      !% Equation VI-4 Page 312
      ! pD=besselk(0,rD*sqrt(s))./(s.^(3/2).*besselk(1,sqrt(s)));
      pD(i) = besselk(0,reD*sqrt(s(i)))/(s(i)**(3.d0/2.d0)*besselk(1,sqrt(s(i))))
   end do

END SUBROUTINE pDINF_Laplace

!--------------------------------------------------------------------------
SUBROUTINE qDINF_Laplace(qD,s,reD,M2)
!--------------------------------------------------------------------------
!% From The Application of the Laplance Transformation to Flow 
!% Problems in Reservoirs. Van Everdingen and W Hurst
!% 1949 AIME
!% The Laplance Transformation and the superimposition theorem
!% offers the basis for interchangin the constant terminal pressure
!% to the constant terminal rate case and vise versa.
!% 
!% 1/s^2=pD*qD   Equation VI-32
!%
!% Elkin Arroyo-Negrete

   complex(dp),intent(in), dimension(0:M2)   :: s
   real(dp)   , intent(in)                   :: reD
   integer    , intent(in)                   :: M2
   complex(dp), intent(out), dimension(0:M2) :: qD
   
   complex(dp), dimension(0:M2):: PD_inf
   integer i

   CALL pDINF_Laplace(PD_inf,s,reD,M2)
   do i=0,M2
      qD(i)=1/(PD_inf(i)*s(i)**2)
      !% Integrate along t cumulative production rather than rate
      !% Q=Int(qD,dt)
      !% Remove comment in line below if you want to generate table 1
      !% from paper Van Enve.. and Hurst see script tableIVanEverdingenHurst.m
      !% qD = qD./s;
      ! Integration with respect to t is just a division in Laplace space
   end do
END SUBROUTINE qDINF_Laplace


!--------------------------------------------------------------------------
FUNCTION qDINFDP(tD,w,lamda,reD_opt,alpha_opt, tol_opt, M_opt) result(qD)
!--------------------------------------------------------------------------
! Solution of the Difusivity Equation for a wellbore
! in a infinite reservoir, homogenous formation
! with a constant pressure drawdonw at wellbore
!
!% 'Definition of variables
!% '
!% '   s = Laplace space variable
!% '   rD = dimensionless distance (radius) = r/rw;
!% '   Note: rD = 1 gives the solution at the wellbore

  real(dp), intent(in)                  :: tD
  real(dp), intent(in)                  :: w
  real(dp), intent(in)                  :: lamda
  real(dp), intent(in), optional        :: reD_opt
  real(dp), intent(in), optional        :: alpha_opt
  real(dp), intent(in), optional        :: tol_opt
  integer,  intent(in), optional        :: M_opt        
  real(dp)                              :: qD
      
  complex(dp),allocatable, dimension(:) :: s
  complex(dp),allocatable, dimension(:) :: F
  real(dp), dimension(1)                :: v_t
  real(dp), dimension(1)                :: v_qD
  real(dp)                              :: reD

  real(dp) :: alpha,tol
  integer  :: M,M2
  
  ! Let's make sure default values are captured 
  ! rD = dimensionless distance (radius) = r/rw;
  ! Note: rD = 1 gives the solution at the wellbore
  if(present(reD_opt))then
     reD = reD_opt
  else
     reD = 1.0D0
  end if
  
  if(present(M_opt))then
     M =M_opt
  else
     M = M__
  end if

  if(present(alpha_opt))then
      alpha=alpha_opt
  else
      alpha=0.d0
  end if
       
  if(present(tol_opt))then
      tol=tol_opt
  else
      tol=1.d-12
  end if

  M2=2*M
  allocate(s(0:M2))
  allocate(F(0:M2))

  ! Find the points in the Laplace Space at which
  ! we need to evaluate the function prior to 
  ! numerical inversion
  ! Laplace Space Evaluation Points
  s = lsep(tD,M,alpha,tol)
  ! Now call Well Model that we want to solve for
  !    qDINFDP_Laplace(qD,s,reD, w,lamda,M2)
  call qDINFDP_Laplace(F, s, reD,w,lamda,M2)

  v_t(1)= tD
  ! Now perform a numerical inversion from Laplace Space
  ! to real time
  call m_invlap(F, v_qD, v_t,1,alpha,tol,M) 
  
  ! For large values to tD algorithm becomes
  ! unstable. Let's remove stability issues by zeroing out
  ! any value of qD less than 1x10^-12
  qD    = v_qD(1)
  
  if(qD .LE. 10**(-12)) then
     qD = 0.D0
  end if
  
  deallocate(s)
  deallocate(F) 
END FUNCTION


!--------------------------------------------------------------------------
SUBROUTINE pDINFDP_Laplace(pD,s,reD,w,lamda,M2)
!--------------------------------------------------------------------------
!% Diffusivity equation solution in laplance space for a radial flow with
!% constant rate inner boundary condition. Constant pressure
!% outler boundary condition and initial condition of pressure pi
!% Radial flow finite wellbore with constant rate production
!% in an infinite-acting reservoir.
!% In dimension less parameters
!% s  : Laplace variable
!% rD : Dimension less radius Allows evaluation of pressure at any point
!% 
!% '=======================================================================
!% 'Reference: paper "The Application of the Laplace Transformation to Flow
!% 'Problems in Reservoirs," Petroleum Transactions, AIME, T.P. 2732.
!% 'Van Everdingen and Hurst 
!% '
!% 'Definition of variables
!% '
!% '   s = Laplace space variable
!% '   Lqd = Laplace transform of the rate solution (constant pressure)
!% '   rD = dimensionless distance (radius) = r/rw;
!% '       Note: rD = 1 gives the solution at the wellbore
!% '
!% '=======================================================================
!% Modify Homogeneous Solution to a dual porosity model with
!% s=u see paper
!% New Solution for Well-Test-Analisys Problems: Part 1 - Analitical
!% Considerations. Ozkan and Raghavan Eq 40
! Dual Porosity Model Main Paper: The Behavior of Naturally
! Fractured Reservoirs. Warren and Root
!
! Ratio of Storativities w = phi2*C2/(phi2*C2+phi1*C1)
! ----------------------------------------------------
! Where index 1 is for Matrix 2 for Fracture
! w=0 negligible storage capacity in the fracture
! w=1 phi1*C1 <<<< phi2*C2 Acts as homogeneous reservoir
!
! Interporosity flow parameter. lamda = alpha*k1*rw^2/'k2
! -------------------------------------------------------
! See equation bottom page 248
! Where 'k2 = sqtr(k2_x*k2_y). alpha: controls flow between
! matrix and fracture
! phi1C1*dP1/dt = alpha*k1/u(P2-P1). Eq (9)
! Where P1: Pressure in matrix
! Also recall f(s)=(w(1-w)s+lamda)/((1-w)s+lamda) Eq (14)
! If lamda -> infinite then f(s)->1 homogeneous behavior

   complex(dp),intent(in), dimension(0:M2)   :: s
   real(dp)   , intent(in)                   :: reD
   real(dp)   , intent(in)                   :: w
   real(dp)   , intent(in)                   :: lamda
   integer    , intent(in)                   :: M2
   complex(dp), intent(out), dimension(0:M2) :: pD
   complex(dp)                               :: u
   integer i

   do i=0,M2
      ! % Dual Porosity Model
      u=s(i)*(w*(1-w)*s(i)+lamda ) / ((1-w)*s(i)+lamda)
      !% Equation VI-4 Page 312
      pD(i) = besselk(0,reD*sqrt(u))/(s(i)**(3.d0/2.d0)*besselk(1,sqrt(u)))
   end do
END SUBROUTINE pDINFDP_Laplace

!--------------------------------------------------------------------------
SUBROUTINE qDINFDP_Laplace(qD,s,reD,w,lamda,M2)
!--------------------------------------------------------------------------
!% From The Application of the Laplance Transformation to Flow 
!% Problems in Reservoirs. Van Everdingen and W Hurst
!% 1949 AIME
!% The Laplance Transformation and the superimposition theorem
!% offers the basis for interchangin the constant terminal pressure
!% to the constant terminal rate case and vise versa.
!% 
!% 1/s^2=pD*qD   Equation VI-32
!%
!% Elkin Arroyo-Negrete

   complex(dp),intent(in), dimension(0:M2)   :: s
   real(dp)   , intent(in)                   :: reD
   real(dp)   , intent(in)                   :: w
   real(dp)   , intent(in)                   :: lamda
   integer    , intent(in)                   :: M2
   complex(dp), intent(out), dimension(0:M2) :: qD
   
   complex(dp), dimension(0:M2)              :: PD_inf
   integer                                   :: i
   
   !    pDINFDP_Laplace(pD,    s,reD,w,lamda,M2)
   CALL pDINFDP_Laplace(PD_inf,s,reD,w,lamda,M2)
   do i=0,M2
      qD(i)=1/(PD_inf(i)*s(i)**2)
   end do
END SUBROUTINE qDINFDP_Laplace


!%------------------------------------------------------------
SUBROUTINE fpDb1(pDb1,s,sqrtu,xeD,yeD,xwD,ywD,xD,yD,maxm)
!function [pDb1]=fpDb1(s,sqrtu,xeD,yeD,xwD,ywD,xD,yD,maxm)
!%------------------------------------------------------------
!% New Solutions for Well-Test-Analisys Problems: Part 2
!% Computation Considerations and Applications
!% Ozkan and Raghavan
!% Ozkan paper eq B-4 page 
!% Ozkan PhD Thesis eq 2.6.32 page 56
! Elkin Arroyo-Negrete

real(dp) , intent(out) :: pDb1
real(dp) , intent(in)  :: s,sqrtu,xeD,yeD,xwD,ywD,xD,yD
integer*4, intent(in)  :: maxm
logical                :: not_done
real(dp)               :: DP,PD1,PD2,yD1,yD2,epsm
integer*4              :: m
   
pDb1 = 0.d0;
m=1;
yD1=yeD-abs(yD-ywD);
yD2=yeD-   (yD+ywD);
not_done=.true.;
epsm = 1d-12;
do while (not_done)
    DP = exp(-2*m*sqrtu*yeD);
    pDb1 = pDb1 + DP;
    not_done = abs(DP) > epsm;
    m=m+1;
    if (m>maxm) then 
        not_done=.false.;
    end if    
end do
pDb1 = 1+pDb1;
pDb1 = pi*pDb1/(xeD*s*sqrtu);
PD1=exp(-sqrtu*(yD+ywD))+exp(-sqrtu*(yeD+yD2));
PD2=exp(-sqrtu*abs(yD-ywD))+exp(-sqrtu*(yeD+yD1));
pDb1 = pDb1*(PD1+PD2);

!% Debug
!write(*,*) 'fpDb1 s=',s,' fpDb1=',pDb1
END SUBROUTINE fpDb1


!%------------------------------------------------------------
SUBROUTINE fpDb2(pDb2,s,u,xeD,yeD,xwD,ywD,xD,yD,maxm)
!function [pDb2]=fpDb2(s,u,xeD,yeD,xwD,ywD,xD,yD,maxm)
!%------------------------------------------------------------
!% New Solutions for Well-Test-Analisys Problems: Part 2
!% Computation Considerations and Applications
!% Ozkan and Raghavan
!% Ozkan paper eq B-5
!% Ozkan thesis eq 2.6.33 page 57

real(dp) , intent(out) :: pDb2
real(dp) , intent(in)  :: s,u,xeD,yeD,xwD,ywD,xD,yD
integer*4, intent(in)  :: maxm
logical                :: not_done, not_donek
real(dp)               :: summ,sumk,pD
real(dp)               :: DP,PD1,PD2,yD1,yD2,epsm,epsk,kpi,epsilonk
integer*4              :: m,k

k=1; 
sumk=0;
not_donek=.true.;
not_done  =.true.;
pDb2=0.d0;

yD1=yeD-abs(yD-ywD);
yD2=yeD-   (yD+ywD);

epsm = 1d-12;
epsk = 1d-12;
do while (not_donek)
  kpi=k*pi/xeD;
  epsilonk=sqrt(u+(kpi)**2);
  m=1;
  summ=0;
  not_done  =.true.; !Earroyo Bug?
  do while (not_done)
     DP = exp(-2*m*epsilonk*yeD);
     summ = summ + DP;
     not_done = abs(DP) > epsm;
     m=m+1;
    if (m>maxm) then  
        not_done=.false.;
    end if
  end do
  pD=exp(-epsilonk*(yD+ywD));
  pD=pD+exp(-epsilonk*(yeD+yD1));
  pD=pD+exp(-epsilonk*(yeD+yD2));
  pD=pD*(1+summ);
  pD=pD+exp(-epsilonk*abs(yD-ywD))*summ;
  sumk = sin(kpi)*cos(kpi*xD)*cos(kpi*xwD)/(k*epsilonk);
  DP   = sumk*pD;
  pDb2 = pDb2 + DP;
  !% Check if function converges and make sure it gets
  !% evaluated at least 3 times
  if(mod(k,4)==0) then
      not_donek = abs(DP) > epsk;
  end if
  k=k+1;
  if (k>maxm)  then
      not_donek=.false.;
  end if
end do
pDb2 = 2*pDb2/s;
END SUBROUTINE fpDb2


!%------------------------------------------------------------
SUBROUTINE fpDb3(pDb3,s,sqrtu,xeD,xwD,xD,maxk)
!function [pDb3]=fpDb3(s,sqrtu,xeD,xwD,xD,maxk)
!%------------------------------------------------------------
!% New Solutions for Well-Test-Analisys Problems: Part 2
!% Computation Considerations and Applications
!% Ozkan and Raghavan
!% Equation B8 page 376 SPE Formation Evaluation, Sep 1991
!% Equation 2.6.41 page 59 Ozkan PhD Thesis

real(dp) , intent(out) :: pDb3
real(dp) , intent(in)  :: s,sqrtu,xeD,xwD,xD
integer*4, intent(in)  :: maxk
integer*4              :: k
logical                :: not_done
real(dp)               :: epsk,xeD2,z
real(dp)               :: IntBesselI0_pl, IntBesselK0_pl
real(dp)               :: IntBesselI0_ls, IntBesselK0_ls
real(dp)               :: sumk, DP

pDb3=0.d0;
sumk=0.d0;
not_done=.true.;
epsk = 1d-12;
k=1;
xeD2=2.d0*xeD;
do while (not_done)
  !% ITIKA Evaluate the integral of modified Bessel functions I0(t) and K0(t)
  !% from 0 to x using series and asymptotic expansions
  z = sqrtu*(k*xeD2-xD+xwD+1.d0);
  ! [IntBesselI0_pl, IntBesselK0_pl]=citika(z);
  call itika(z,IntBesselI0_pl,IntBesselK0_pl);
  z = sqrtu*(k*xeD2-xD+xwD-1.d0);
  ! [IntBesselI0_ls, IntBesselK0_ls]=citika(z);
  call itika(z,IntBesselI0_ls, IntBesselK0_ls);
  DP = (IntBesselK0_pl-IntBesselK0_ls);
  
  z = sqrtu*(k*xeD2+xD-xwD+1.d0);
  ! [IntBesselI0_pl, IntBesselK0_pl]=citika(z);
  call itika(z,IntBesselI0_pl, IntBesselK0_pl);
  z = sqrtu*(k*xeD2+xD-xwD-1.d0);
  ! [IntBesselI0_ls, IntBesselK0_ls]=citika(z);
  call itika(z,IntBesselI0_ls, IntBesselK0_ls);
  DP = DP + (IntBesselK0_pl-IntBesselK0_ls);

  z = sqrtu*(k*xeD2-xD-xwD+1.d0);
  ! [IntBesselI0_pl, IntBesselK0_pl]=citika(z);
  call itika(z,IntBesselI0_pl, IntBesselK0_pl);
  z = sqrtu*(k*xeD2-xD-xwD-1.d0);
  ! [IntBesselI0_ls, IntBesselK0_ls]=citika(z);
  call itika(z,IntBesselI0_ls, IntBesselK0_ls);
  DP = DP + (IntBesselK0_pl-IntBesselK0_ls);

  z = sqrtu*(k*xeD2+xD+xwD+1.d0);
  ! [IntBesselI0_pl, IntBesselK0_pl]=citika(z);
  call itika(z,IntBesselI0_pl, IntBesselK0_pl);
  z = sqrtu*(k*xeD2+xD+xwD-1.d0);
  ! [IntBesselI0_ls, IntBesselK0_ls]=citika(z);
  call itika(z,IntBesselI0_ls, IntBesselK0_ls);
  DP = DP + (IntBesselK0_pl-IntBesselK0_ls);
  sumk = sumk + DP;
  ! % Check if function converges and make sure it gets
  ! % evaluated at least 3 times
  if(mod(k,4)==0) then
      not_done = abs(DP) > epsk;
  end if
  k=k+1;
  if (k>maxk) then  
        not_done=.false.;
  end if   
end do

z=sqrtu*(xD+xwD+1.d0);
![IntBesselI0_pl, IntBesselK0_pl]=citika(z);
call itika(z,IntBesselI0_pl, IntBesselK0_pl);
z=sqrtu*(xD+xwD-1.d0);
! [IntBesselI0_ls, IntBesselK0_ls]=citika(z);
call itika(z,IntBesselI0_ls, IntBesselK0_ls);
pDb3 = sumk + (IntBesselK0_pl-IntBesselK0_ls);
pDb3 = pDb3/(2.d0*s*sqrtu);
pDb3 = pDb3 - pi/(xeD*s*sqrtu);
END SUBROUTINE fpDb3


!%------------------------------------------------------------
SUBROUTINE fpD1(pD1,s,u,xeD,xwD,ywD,xD,yD,maxk)
!function [pD1]=fpD1(s,u,xeD,xwD,ywD,xD,yD,maxk)
!%------------------------------------------------------------
!% Eq B-2 page 376 SPE Formation Evaluation, Sep 1991
!% Eq 2.6.31 Page 56 Ozkan PhD Thesis

real(dp) , intent(out) :: pD1
real(dp) , intent(in)  :: s,u,xeD,xwD,ywD,xD,yD
integer*4, intent(in)  :: maxk
integer*4              :: k
logical                :: not_done
real(dp)               :: epsilonk, sumk,kpi,epsk,DP


k=1; 
sumk=0.d0;
not_done  =.true.;
epsk = 1d-20;
do while (not_done)
  kpi=k*pi/xeD;
  epsilonk=sqrt(u+(kpi)**2);
  DP = sin(kpi)*cos(kpi*xD)*cos(kpi*xwD)/(k*epsilonk);
  DP = DP*exp(-epsilonk*abs(yD-ywD));
  sumk = sumk + DP;

  !% Check if function converges and make sure it gets
  !% evaluated at least 10 times  
  if(mod(k,10)==0) then
   not_done = abs(DP) > epsk;
  end if
  
  k=k+1;
  if(k>maxk) then
        not_done=.false.;
  end if
end do
pD1=2.d0*sumk/s;

END SUBROUTINE fpD1

!%------------------------------------------------------------
SUBROUTINE fpDINF(pDINF,s,sqrtu,xD,xwD)
!function [pDINF]=fpDINF(s,sqrtu,xD,xwD)
!%------------------------------------------------------------
!% Equation 15 or 16 Ozkan paper page 370
!% Ozkan PhD Thesis Eq 2.6.1 or 2.6.2 page 42 & 43
! Notice this function is already implemented in the same file 
! as SUBROUTINE pDFracINF_Laplace(PD_cfracs_inf,s,xD,M2)
! the former implentation is superseed by this one here
! current implementation takes as input real values of s
! while former takes as input complex values of s
! current implementation is also more general because the input
! for the dual porosity model is variable u; former function
! the dual porosity model is within the function making it
! dependant on the type chooice of dual porosity model
!-------------------------------------------------------------
!% Function computes the Dimensionless Solution of a Vertically
!% Fracture Well, Infinite Acting Reservoir Reservoir.
!% Uniform Flux Case XD=0 / Infinite Conductivity XD=0.732
!% Elkin Arroyo-Negrete
!% 06-Sep-2012 
! See paper: 
! New Solution for Well-Test-Analisys Problems: Part 1 - 
! Analitical Considerations. SPE Formation Evaluation 1991
! Erdal Ozkan and Rajagopal Raghavan, page 340 Table
! Solution for wells in Infinte Reservoirs 
! Fractured Well. Also see more computational efficient
! re-arrangement of same equation at Page 362 Equation 40

real(dp) , intent(out) :: pDINF
real(dp) , intent(in)  :: s,sqrtu,xD,xwD
real(dp) :: IntBesselI0_ls, IntBesselK0_ls
real(dp) :: IntBesselI0_pl, IntBesselK0_pl
real(dp) :: z

!% ITIKA Evaluate the integral of modified Bessel functions I0(t) and K0(t)
!% from 0 to x using series and asymptotic expansions.
z = sqrtu*(1.d0-(xD-xwD));
![IntBesselI0_ls, IntBesselK0_ls]=citika(z);
call itika(z,IntBesselI0_ls, IntBesselK0_ls);
z = sqrtu*(1.d0+(xD-xwD));
! [IntBesselI0_pl, IntBesselK0_pl]=citika(z);
call itika(z,IntBesselI0_pl, IntBesselK0_pl);
pDINF = (IntBesselK0_ls+IntBesselK0_pl)/(2.d0*s*sqrtu);

!% Debug
!msg=sprintf('fpDINF s=%f sqrtu=%f xD=%f xwD=%f pDINF=%f',s,sqrtu,xD,xwD,pDINF);
!write(*,*) 'fpDINF s=',s, 'sqrtu=',sqrtu, 'xD=',xD,'xwD=',xwD,' pDINF=',pDINF
! disp(msg);
END SUBROUTINE  fpDINF

!--------------------------------------------------------------------
FUNCTION pDVSqNFB(t,xD,xeD,yeD,xwD,ywD,w,lamda,Cd,skin) result(pD)
!--------------------------------------------------------------------
! Pressure Response Bounded Reservoir in a Squared Domain
! By Default uses Infinite Conductivity Fracture xD=0.732
! and Homogeneous domain. If user wants to specify dual
! porosity then the optional parameters w, lamda need to
! be specified
!
!                        dp/dy=0
!         __________________________________________  __________
!        |                                          |          ^
!        |                                          |          |
!        | <---------------  xe-------------------->|          |
!        |                                          |          |
!        |                                          |          |
!        |         <-- xf ---                       |          |
!dp/dx=0 |         ==========0==========            | dp/dx=0  |
!        |                   |         ^            |          |
!        |                   |         |            |         ye
!        |                   |         |            |          |
!        |                   |        yw            |          |
!        |                   |         |            |          |
!        |                   |         |            |          |
!        |___________________|_________\/___________| _______ \ /     
!         <-------xw--------->      dp/dy=0
!

real(dp), intent(in)            :: t,xD,xeD,yeD,xwD,ywD
real(dp), intent(in)            :: w,lamda, Cd, skin
real(dp)                        :: pD,s,u,sqrtu,pDINF

! ROOM FOR IMPROVEMENT VARIABLES BELOW SHOULD BE ALLOCATABLE
! SO n CAN BE ANY SIZE
real(dp), dimension(20)         :: LpD,ss
integer*4                       :: i,n

n = GAVER_STEHFEST_N

! Evaluate well model in Laplace Space
call Laplace_pDVSqNFB(LpD,ss,n,t,xD,xeD,yeD,xwD,ywD,w,lamda,Cd,skin)

! Numerically invert function from Laplace space to time
call m_invlapGS(pD,LpD,t,n)
! We can also compute pressure derivative

! Check if we got NA as answer. If that is the case it means
! we are in the infinite reD portion of the curve and as such
! we can call the infinte solution 
if(pD .NE. pD) then
   do i=1,n
     ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
     s = ss(i);
     u=s*(w*(1-w)*s+lamda ) / ((1-w)*s+lamda);
     sqrtu = sqrt(u);     
     call fpDINF(pDINF,s,sqrtu,(xwD+xD),xwD);
     LpD(i) = CdSkin(s,pDINF,Cd,skin)
   end do  
   call m_invlapGS(pD,LpD,t,n)
end if
END FUNCTION pDVSqNFB


!--------------------------------------------------------------------
FUNCTION qDVSqNFB(t,xD,xeD,yeD,xwD,ywD,w,lamda,Cd,skin) result(qD)
!--------------------------------------------------------------------
! Rate for a Bounded Reservoir in a Squared Domain
! with cte pressure at wellbore

real(dp), intent(in)            :: t,xD,xeD,yeD,xwD,ywD
real(dp), intent(in)            :: w,lamda, Cd, skin
real(dp)                        :: qD,s,u,sqrtu,pDINF

! ROOM FOR IMPROVEMENT VARIABLES BELOW SHOULD BE ALLOCATABLE
! SO n CAN BE ANY SIZE
real(dp), dimension(20)         :: LpD,LqD,ss
integer*4                       :: i,n

n = GAVER_STEHFEST_N

! Evaluate well model in Laplace Space
call Laplace_pDVSqNFB(LpD,ss,n,t,xD,xeD,yeD,xwD,ywD,w,lamda,Cd,skin)

! Now move from pD to qD
call pD2qD(LqD,ss,LpD,n)

! Numerically invert function from Laplace space to time
call m_invlapGS(qD,LqD,t,n)
! We can also compute cumulative production

! Check if we got NA as answer. If that is the case it means
! we are in the infinite reD portion of the curve and as such
! we can call the infinte solution 
if(qD .NE. qD) then
   do i=1,n
     ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
     s = ss(i);
     u=s*(w*(1-w)*s+lamda ) / ((1-w)*s+lamda);
     sqrtu = sqrt(u);     
     call fpDINF(pDINF,s,sqrtu,(xwD+xD),xwD);
     LpD(i) = CdSkin(s,pDINF,Cd,skin)
   end do
   ! Now move from pD to qD   
   call pD2qD(LqD,ss,LpD,n)
   call m_invlapGS(qD,LqD,t,n)
end if

END FUNCTION qDVSqNFB

!--------------------------------------------------------------------
FUNCTION CumqDVSqNFB(t,xD,xeD,yeD,xwD,ywD,w,lamda,Cd,skin) result(qD)
!--------------------------------------------------------------------
! Cum Rate for a Bounded Reservoir in a Squared Domain
! with cte pressure at wellbore

real(dp), intent(in)            :: t,xD,xeD,yeD,xwD,ywD
real(dp), intent(in)            :: w,lamda, Cd, skin
real(dp)                        :: qD,s,u,sqrtu,pDINF

! ROOM FOR IMPROVEMENT VARIABLES BELOW SHOULD BE ALLOCATABLE
! SO n CAN BE ANY SIZE
real(dp), dimension(20)         :: LpD,LqD,ss
integer*4                       :: i,n

n = GAVER_STEHFEST_N

! Evaluate well model in Laplace Space
call Laplace_pDVSqNFB(LpD,ss,n,t,xD,xeD,yeD,xwD,ywD,w,lamda,Cd,skin)

! Now move from pD to qD
call pD2CumqD(LqD,ss,LpD,n)

! We can also compute cumulative production
! Now Integrate qD to QD - save the information in LpD
! call Integral(LpD,ss,LqD,n)

! Numerically invert function from Laplace space to time
call m_invlapGS(qD,LqD,t,n)

! Check if we got NA as answer. If that is the case it means
! we are in the infinite reD portion of the curve and as such
! we can call the infinte solution 
!if(qD .NE. qD) then
!   do i=1,n
     ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
!     s = ss(i);
!     u=s*(w*(1-w)*s+lamda ) / ((1-w)*s+lamda);
!     sqrtu = sqrt(u);     
!     call fpDINF(pDINF,s,sqrtu,(xwD+xD),xwD);
!     LpD(i) = CdSkin(s,pDINF,Cd,skin)
!   end do
   ! Now move from pD to qD   
!   call pD2CumqD(LqD,ss,LpD,n)
   ! call Integral(LpD,ss,LqD,n)
!   call m_invlapGS(qD,LqD,t,n)
!end if

END FUNCTION CumqDVSqNFB


!-------------------------------------------------------------------------
SUBROUTINE Laplace_pDVSqNFB(pD,ss,n,t,xD,xeD,yeD,xwD,ywD,w,lamda,Cd,skin)
!-------------------------------------------------------------------------
real(dp), intent(out), dimension(n):: pD
real(dp), intent(out), dimension(n):: ss
real(dp), intent(in)               :: t, xD,xeD,yeD,xwD,ywD
real(dp), intent(in)               :: w,lamda, Cd, skin
integer(kind=4), intent(in)        :: n


real(dp)                        :: s
real(dp)                        :: AD,pDb,pD1,pDb1,pDb2,pDb3
real(dp)                        :: pDINF,tDA 
real(dp)                        :: sqrtu,u,yD,xD_
integer(kind=4)                 :: i, maxn

! Maximun Number of Sumation Evaluation
maxn = MAXN__;

! Evaluate function at well location
yD   = ywD;

! Infinite Conductivity Reservoir 
! xD=0 Uniform Flux, xD=0.732 Infinite Conductivity
xD_=xwD+xD;


! Find the Laplace s evaluation points for a given t
call lsepGS(ss, t, n)
AD = xeD*yeD;
tDA= t/AD;

do i=1,n
  ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
  ! Create a class object with all the dual 
  ! porosity model avaliables
  ! User can the select which dual porosity model
  ! to use using a enum variable
  ! By Default using Warrent and Root
  ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
  s = ss(i);
  u=s*(w*(1-w)*s+lamda ) / ((1-w)*s+lamda);
  sqrtu = sqrt(u);
  call fpDb1(pDb1,s,sqrtu,xeD,yeD,xwD,ywD,xD_,yD,maxn);
  ! write(*,*) 'fpDb1=' , pDb1
  call fpDb2(pDb2,s,u,xeD,yeD,xwD,ywD,xD_,yD,maxn);
  ! write(*,*) 'fpDb2=' , pDb2
  if(tDA>0.01d0) then
     call fpD1(pD1,s,u,xeD,xwD,ywD,xD_,yD,maxn);
     ! write(*,*) 'fpD1=' , pD1
     pD(i) = pD1+pDb1+pDb2;
  else
     call fpDb3(pDb3,s,sqrtu,xeD,xwD,xD_,maxn);
     call fpDINF(pDINF,s,sqrtu,xD_,xwD);
     ! write(*,*) 'fpDINF=' , pDINF, ' fpDb3', pDb3
     pDb    = pDb1+pDb2+pDb3;
     pD(i) = pDINF+pDb; 
  end if
  ! Add wellbore storage and skin
  pD(i) = CdSkin(s,pD(i),Cd,skin)
  ! write(*,*) 'n=',n
end do

END SUBROUTINE Laplace_pDVSqNFB

!----------------------------------------------------
FUNCTION CdSkin(s,pD,Cd,skin) result(pwD)
!----------------------------------------------------
! Equation 2.8.1 Ozkan Thesis page 93
! Equation VIII-5 Everdingen and Hurst page 323
! Where 
!  pD  : Pressure
!  Cd  : Wellbore storage
!  skin: Skin effect
!  s   : Laplace variable
!
! Cd Dimensionless wellbore storage constant
! Cd = 5.61*CD/(2*pi*phi*ct*h*L^2)

real(dp), intent(in) :: s,pD,Cd,skin
real(dp)             :: pwD

pwD = (s*pD+skin)/(s+Cd*s*s*(s*pD+skin));

END FUNCTION CdSkin

!----------------------------------------------------
SUBROUTINE pD2qD(qD, s,pD,n) ! result (qD)
!----------------------------------------------------
! From The Application of the Laplance Transformation to Flow 
! Problems in Reservoirs. Van Everdingen and W Hurst
! 1949 AIME
! The Laplance Transformation and the superimposition theorem
! offers the basis for interchangin the constant terminal 
! pressure to the constant terminal rate case and vise versa.
! 
! 1/s^2=pD*qD   Equation VI-32
!
! Elkin Arroyo-Negrete

real(dp), intent(in), dimension(n)  :: s
real(dp), intent(in), dimension(n)  :: pD
integer(kind=4)     ,  intent(in)   :: n
real(dp), dimension(n), intent(out) :: qD
integer(kind=4)                     :: i

do i=1,n
   qD(i)=1.d0/(pD(i)*s(i)*s(i))
end do

END SUBROUTINE pD2qD

!----------------------------------------------------
SUBROUTINE pD2dpD(dpD, s,pD,n) ! result (qD)
!----------------------------------------------------

real(dp), intent(in), dimension(n)  :: s
real(dp), intent(in), dimension(n)  :: pD
integer(kind=4)     ,  intent(in)   :: n
real(dp), dimension(n), intent(out) :: dpD
integer(kind=4)                     :: i

do i=1,n
   dpD(i)= pD(i)*s(i)
end do

END SUBROUTINE pD2dpD


!----------------------------------------------------
SUBROUTINE pD2CumqD(cumqD,s,pD,n) ! result(intF)
!----------------------------------------------------
!
!
real(dp), intent(in), dimension(n)  :: s
real(dp), intent(in), dimension(n)  :: pD
integer(kind=4)     ,  intent(in)   :: n
real(dp), dimension(n), intent(out) :: cumqD

integer(kind=4)                     :: i

do i=1,n
  cumqD(i) = 1.d0/(pD(i)*s(i)**3.d0)
end do

END SUBROUTINE pD2CumqD


!----------------------------------------------------
FUNCTION Derivative(s,F) result (dF)
!----------------------------------------------------
!
!
real(dp), intent(in)  :: s
real(dp), intent(in)  :: F
real(dp)              :: dF

dF = s*F

END FUNCTION Derivative


!--------------------------------------------------------
! Functions below corresponds to Horizontal solution
! ROOM for improvement 
! There should be a base object well then different
! clases for each well model
!
! Equations below were initially progamened in fortran
! check functions 
! pfD =pDVSqNFB   / F =pDHorzPseudoSkin2651
! Fb1 =pDHorz2646 / Fb2 =pDHorz2647 / Fb3 =pDHorz2656
!
! Full solution is given by 
! pD=pfD+F1;
! Where
! Fb =Fb1+Fb2+Fb3 / F1=F+Fb;
!
! Elkin Arroyo-Negrete - 05/26/2013
!--------------------------------------------------------


!--------------------------------------------------------------------------------------
SUBROUTINE pDHorzPseudoSkin2651(F,s,u,xD,zD,zwD,LD,eps)
! function [FD]=pDHorzPseudoSkin2651(s,u,xD,zD,zwD,LD,eps)
!--------------------------------------------------------------------------------------
! Function computes the pseudoskin function for a horizontal
! well. This pseudoskin function appears in the solution of
! the following problems
!
! Horizontal well on a infinite acting reservoir
! See Ozkan PhD thesis Eq 2.6.9 page 47
! 
! Horizontal well on bounded reservoir
! See Ozkan PhD thesis Eq 2.6.51 page 65
!
! See also SPE Paper
! New Solution for Well-Test-Analisys Problems
! Part 2-Computational Considerations and Applications
! Erdal Ozkan & Rajagopal Raghavan
! Eq 21 page 370
! 
! WARNING:
! Notice if functions is called for a horizontal
! bounded reservoir then user will need to evaluate
! xD as (xD-xwD)

real(dp) , intent(out) :: F
real(dp) , intent(in)  :: s,u,xD,zD,zwD,LD,eps

integer(kind=4)        :: n,maxn
logical                :: not_done

real(dp)               :: en,npi,FD
real(dp)               :: IntBesselI0_ls, IntBesselK0_ls
real(dp)               :: IntBesselI0_pl, IntBesselK0_pl
real(dp)               :: z,DelP

! Maximun Number of Sumation Evaluation
maxn = MAXN__;

n=1;
not_done = .true.;

do while (not_done)
    npi = n*pi;
    en  = sqrt(u+(npi*LD)**2);
    DelP  = cos(npi*zD)*cos(npi*zwD)/en;
    z   = en*(1-xD);
    ![IntBesselI0_ls, IntBesselK0_ls]=citika(z);
    call itika(z,IntBesselI0_ls, IntBesselK0_ls);
    z   = en*(1+xD);
    
    ![IntBesselI0_pl, IntBesselK0_pl]=citika(z);
    call itika(z,IntBesselI0_pl, IntBesselK0_pl);
    DelP  = DelP*(IntBesselK0_ls+IntBesselK0_pl);
    FD = FD + DelP;
    ! Check if we are done
    if(mod(n,3)==0) then
      not_done = abs(DelP) > eps;
    end if
    if (n>maxn) then
        not_done=.false.;
    end if
    n=n+1;            
end do

! Line below I think will improve accuracy specially
! for large values of s. Check presentation 
! FD_pseudoskingConverAnalisys.pptx in same directory
! as file
! FD = (FD + FDn)/2;
F = FD/s;

END SUBROUTINE pDHorzPseudoSkin2651


!------------------------------------------------------------------------
SUBROUTINE pDHorz2646(Fb1,s,u,xeD,yD,yeD,ywD,zD,zwD,LD,epsn,epsm)
! function [Fb1]=pDHorz2646(s,u,xeD,yD,yeD,ywD,zD,zwD,LD,epsn,maxn,epsm,maxm)
!------------------------------------------------------------------------
! Function makes part of ths solution of Horizontal Well
! Bounded Reservoir
!
! Notice complete solution is given by
!
! pD = pfD + F1
! F1 = F + Fb
! Fb = Fb1+Fb2+Fb3
!
! Fb1 is explained at 
! See Ozkan PhD thesis Eq 2.6.46 page 63
! See also  
! New Solution for Well-Test-Analisys Problems
! Part 2-Computational Considerations and Applications
! Erdal Ozkan & Rajagopal Raghavan
! Eq B-13 page 376
! 
! As a site note the overall structure of the equation is
! similar to Ozkan paper eq B-5 & Ozkan thesis eq 2.6.33 
! page 57

real(dp) , intent(out) :: Fb1
real(dp) , intent(in)  :: s,u,xeD,yD,yeD,ywD,zD,zwD,LD,epsn,epsm

integer(kind=4)        :: m,n,maxn,maxm
logical                :: not_donen,not_donem
real(dp)               :: yD1,yD2
real(dp)               :: npi, pD,summ,sumn,epsilonn,twopi,DP

! Maximun Number of Sumation Evaluation
maxn = MAXN__;
maxm = MAXN__;

yD1 = yeD-abs(yD-ywD);
yD2 = yeD-   (yD+ywD);

n=1; 
Fb1=0;
twopi = 2*pi;
not_donen = .true.;
do while (not_donen)
  !% Code below should be programed as external
  !% function similar function appears in eq B-5
  npi=n*pi;
  epsilonn = sqrt(u+(npi*LD)**2);
  m=1; 
  summ=0;
  not_donem=.true.;
  do while (not_donem)
    DP = exp(-2*m*epsilonn*yeD);
    summ = summ + DP;
    not_donem = abs(DP)>epsm;
    m = m+1;
    if(m>maxm) then
      not_donem=.false.;
    end if
  end do
  pD =    exp(-epsilonn*(yD+ywD));
  pD = pD+exp(-epsilonn*(yD+yD1));
  pD = pD+exp(-epsilonn*(yD+yD2));
  pD = pD*(1+summ);
  pD = pD+exp(-epsilonn*abs(yD-ywD))*summ;
  sumn = cos(npi*zD)*cos(npi*zwD)/epsilonn;
  DP   = sumn*pD;
  Fb1 = Fb1 + DP;
  !% Check if functions converges and make sure
  !% it gets evaluated at least 3 times
  if(mod(n,4)==0) then
    not_donen = abs(DP) > epsn; 
  end if
  n = n+1;
  if(n>maxn) then
     not_donen=.false.;
  end if
end do
Fb1 = twopi*Fb1/(xeD*s);

END SUBROUTINE pDHorz2646


!--------------------------------------------------------------------------------------
SUBROUTINE pDHorz2647(Fb2,s,u,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,epsn,epsm,epsk)
! function [Fb2]=pDHorz2647(s,u,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD)
!--------------------------------------------------------------------------------------
! Function makes part of the solution of Horizontal Well
! Bounded Reservoir
!
! Notice complete solution is given by
!
! pD = pfD + F1
! F1 = F + Fb
! Fb = Fb1+Fb2+Fb3
!
! Fb2 is explained at 
! See Ozkan PhD thesis Eq 2.6.47 page 64
! See also  
! New Solution for Well-Test-Analisys Problems
! Part 2-Computational Considerations and Applications
! Erdal Ozkan & Rajagopal Raghavan
! Eq B-14 page 377
! 
! As a site note the overall structure of the equation is
! similar to Ozkan paper eq B-12 & Ozkan thesis eq 2.6.46 

real(dp) , intent(out) :: Fb2
real(dp) , intent(in)  :: s,u,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,epsn,epsm,epsk

integer(kind=4)        :: m,n,k,maxn,maxm,maxk
logical                :: not_donen,not_donem,not_donek
real(dp)               :: yD1,yD2
real(dp)               :: kpi, npi,pD,summ,sumn,sumk,epsilonkn,Fbk,pixeD,DP

!epsn=1e-16;
!epsm=1e-16;
!epsk=1e-23;

maxn=MAXN__;
maxm=MAXN__;
maxk=MAXN__;

yD1 = yeD-abs(yD-ywD);
yD2 = yeD-   (yD+ywD);

n=1; Fb2=0;
not_donen=.true.;
pixeD=pi/xeD;
do while (not_donen)
   npi=n*pi;
   k=1; 
   Fbk=0;
   not_donek=.true.;
   do while (not_donek)
     ! Code below should be programed as external
     ! function similar function appears in eq B-5
     kpi=k*pixeD;
     epsilonkn = sqrt(u+(npi*LD)**2+(kpi)**2);
     m=1; 
     summ=0;
     not_donem=.true.;
     do while (not_donem)
       DP = exp(-2*m*epsilonkn*yeD);
       summ = summ + DP;
       not_donem = abs(DP)>epsm;
       m = m+1;
       if(m>maxm) then
         not_donem=.false.;
       end if
     end do

     pD =    exp(-epsilonkn*(yD+ywD));
     pD = pD+exp(-epsilonkn*(yD+yD1));
     pD = pD+exp(-epsilonkn*(yD+yD2));
     pD = pD*(1+summ);
     pD = pD+exp(-epsilonkn*abs(yD-ywD))*summ;
     sumk = sin(kpi)*cos(kpi*xD)*cos(kpi*xwD)/(k*epsilonkn);
     DP  = sumk*pD;
     Fbk = Fbk+DP;
     ! Check if functions converges and make sure
     ! it gets evaluated at least 3 times
     if(mod(k,10)==0) then
       not_donek = abs(DP) > epsk; 
     end if
     k = k+1;
     if(k>maxk) then
       not_donek=.false.;
     end if
   end do
   sumn = cos(npi*zD)*cos(npi*zwD);   
   DP   = sumn*Fbk;
   Fb2  = Fb2 + DP;
   ! Check if functions converges and make sure
   ! it gets evaluated at least 3 times
   if(mod(n,4)==0) then
     not_donen = abs(DP) > epsn; 
   end if
   n = n+1;
   if(n>maxn) then
      not_donen=.false.;
   end if
end do
Fb2 = 4*Fb2/s;

END SUBROUTINE pDHorz2647


!--------------------------------------------------------------------------------------
SUBROUTINE pDHorz2656(Fb3,s,u,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,epsn,epsk)
!function [ Fb3 ] = pDHorz2656(s,u,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD)
!--------------------------------------------------------------------------------------
! Function makes part of ths solution of Horizontal Well
! Bounded Reservoir
!
! Notice complete solution is given by
!
! pD = pfD + F1
! F1 = F + Fb
! Fb = Fb1+Fb2+Fb3
!
! Fb3 is explained at 
! See Ozkan PhD thesis Eq 2.6.56 page 67
! See also  
! New Solution for Well-Test-Analisys Problems
! Part 2-Computational Considerations and Applications
! Erdal Ozkan & Rajagopal Raghavan
! Eq B-17 page 377
! 
! As a site note the overall structure of the equation is
! similar to Ozkan paper eq XX & Ozkan thesis eq 2.6.41 

real(dp) , intent(out) :: Fb3
real(dp) , intent(in)  :: s,u,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,epsn,epsk

integer(kind=4)        :: n,k,maxn,maxk
logical                :: not_donen,not_done
real(dp)               :: IntBesselI0_ls, IntBesselK0_ls
real(dp)               :: IntBesselI0_pl, IntBesselK0_pl
real(dp)               :: z,npi,xeD2,sumn,sumk,a,sqrtua,DP

!epsk = 1e-16;
!epsn = 1e-16;

maxn=MAXN__;
maxk=MAXN__;

xeD2=2*xeD;
Fb3=0;
n=1;
not_donen=.true.;
do while (not_donen)
  npi   =n*pi;  
  a     =(npi*LD)**2; 
  sqrtua=sqrt(u+a);
  sumk=0; 
  k=1;
  not_done=.true.;
  do while (not_done)
    z = sqrtua*(k*xeD2-xD+xwD+1);
    ! [IntBesselI0_pl, IntBesselK0_pl]=citika(z);
    call itika(z,IntBesselI0_pl, IntBesselK0_pl);
    z = sqrtua*(k*xeD2-xD+xwD-1);
    ! [IntBesselI0_ls, IntBesselK0_ls]=citika(z);
    call itika(z,IntBesselI0_ls, IntBesselK0_ls);
    DP = (IntBesselK0_pl-IntBesselK0_ls);
    
    z = sqrtua*(k*xeD2+xD-xwD+1);
    call itika(z,IntBesselI0_pl, IntBesselK0_pl);
    z = sqrtua*(k*xeD2+xD-xwD-1);
    call itika(z,IntBesselI0_ls, IntBesselK0_ls);
    DP = DP + (IntBesselK0_pl-IntBesselK0_ls);

    z = sqrtua*(k*xeD2-xD-xwD+1);
    call itika(z,IntBesselI0_pl, IntBesselK0_pl);    
    z = sqrtua*(k*xeD2-xD-xwD-1);
    call itika(z,IntBesselI0_ls, IntBesselK0_ls);
    DP = DP + (IntBesselK0_pl-IntBesselK0_ls);

    z = sqrtua*(k*xeD2+xD+xwD+1);
    call itika(z,IntBesselI0_pl, IntBesselK0_pl);        
    z = sqrtua*(k*xeD2+xD+xwD-1);
    call itika(z,IntBesselI0_ls, IntBesselK0_ls);    
    DP = DP + (IntBesselK0_pl-IntBesselK0_ls);
    
    sumk = sumk + DP;
    !% Check if function converges and make sure it gets
    !% evaluated at least 3 times
    if(mod(k,4)==0) then
        not_done = abs(DP) > epsk;
    end if
    k=k+1;
    if (k>maxk)  then
          not_done=.false.;
    end  if
  end do

  z=sqrtua*(xD+xwD+1);
  call itika(z,IntBesselI0_pl, IntBesselK0_pl);          
  z=sqrtua*(xD+xwD-1);
  call itika(z,IntBesselI0_ls, IntBesselK0_ls);    
  sumk = sumk + (IntBesselK0_pl-IntBesselK0_ls);
  
  sumn = cos(npi*zD)*cos(npi*zwD)/sqrtua;
  DP   = sumn*sumk;
  Fb3  = Fb3 + DP;
  !% Check if functions converges and make sure
  !% it gets evaluated at least 3 times
  if(mod(n,4)==0) then
    not_donen = abs(DP) > epsn; 
  end if
  n = n+1;
  if(n>maxn) then
     not_donen=.false.;
  end if
end do
Fb3=Fb3/s;

END SUBROUTINE pDHorz2656

!--------------------------------------------------------------------------------------
SUBROUTINE Laplace_pDHorzNFB(pD,ss,n,tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,w,lambda,Cd,skin)
!           [pD] = pDHorzNFB(   s ,tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,w,lambda)
!--------------------------------------------------------------------------------------
real(dp), intent(out), dimension(n):: pD
real(dp), intent(out), dimension(n):: ss
real(dp), intent(in)               :: tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD
real(dp), intent(in)               :: w,lambda, Cd, skin
integer(kind=4), intent(in)        :: n

real(dp)                           :: s,u
real(dp)                           :: F,F1,Fb,Fb1,Fb2,Fb3
integer(kind=4)                    :: i
real(dp)                           :: epsn,epsm
real(dp), dimension(n)             :: pfD


CHARACTER (LEN=256) ERRFILENAME
CHARACTER (LEN=256)::CURDIR
INTEGER            ::erro
! erro=getcwd(CURDIR)
! ERRFILENAME = TRIM(CURDIR)//'\pDHorzNFBDLL_Err.txt'
! OPEN (UNIT = 102, FILE = ERRFILENAME, ACCESS='append')

epsn = 1.0d-23
epsm = 1.0d-12

! Find the Laplace s evaluation points for a given t
! call lsepGS(ss, t, n)
! Notice function below will call call lsepGS(ss, t, n) no need to call it here
! again
call Laplace_pDVSqNFB(pfD,ss,n,tD,xD-xwD,xeD,yeD,xwD,ywD,w,lambda,Cd,skin)

do i=1,n
  ! WRITE(102,*) 's',ss(i)
  ! WRITE(102,*) 'pDVSqNFB=',pfD(i)
  ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
  ! Create a class object with all the dual 
  ! porosity model avaliables
  ! User can the select which dual porosity model
  ! to use using a enum variable
  ! By Default using Warrent and Root
  ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
  s = ss(i);
  u=s*(w*(1-w)*s+lambda ) / ((1-w)*s+lambda);
  call pDHorzPseudoSkin2651(F,s,u,xD-xwD,zD,zwD,LD,epsn)
  ! WRITE(102,*) 'pDHorzPseudoSkin2651=',F
  call pDHorz2646(Fb1,s,u,xeD,yD,yeD,ywD,zD,zwD,LD,epsm,epsm)
  ! WRITE(102,*) 'pDHorz2646=',Fb1
  call pDHorz2647(Fb2,s,u,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,epsm,epsm,epsm)
  ! WRITE(102,*) 'pDHorz2647=',Fb2
  call pDHorz2656(Fb3,s,u,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,epsm,epsm)
  ! WRITE(102,*) 'pDHorz2656=',Fb3
  Fb =Fb1+Fb2+Fb3;
  F1=F+Fb;
  pD(i) =pfD(i)+F1;
  ! Add wellbore storage and skin
  pD(i) = CdSkin(s,pD(i),Cd,skin)  
end do

! CLOSE(102)

END SUBROUTINE Laplace_pDHorzNFB

!-----------------------------------------------------------------------------------
FUNCTION pDHorzNFB(tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,w,lambda,Cd,skin)  result(pD)
!-----------------------------------------------------------------------------------
! Pressure Response Horizontal Well Bounded Reservoir in a Squared Domain
! By Default uses Infinite Conductivity Fracture xD=0.732
! and homogeneous domain. If user wants to specify dual porosity 
! then the optional parameters w, lamda need to be specified
! 
! Elkin Arroyo-Negrete 05/27/2013
!
! Typically zwD is evaluated ad a given point zD + rwD
! Notice that the origin of the cordinate system is the 
! bottom left corner.
! Reference lenght is based on the horizontal half lengh
!
!                        dp/dy=0
!         __________________________________________  __________
!        |                                          |          ^
!        |                                          |          |
!        | <--------------- xeD-------------------->|          |
!        |                                          |          |
!        |                                          |          |
!        |         <-------- LD ------>             |          |
!dp/dx=0 |         0===================             | dp/dx=0  |
!        |                   |         ^            |          |
!        |                   |         |            |         yeD
!        |                   |         |            |          |
!        |                   |        ywD           |          |
!        |                   |         |            |          |
!        |                   |         |            |          |
!        |___________________|_________\/___________| _______ \ /     
!         <-------xw--------->      dp/dy=0
!
!        ___________________________________________  ______
!        |          ||                              |       ^
!        |          ||                              |       |
!        |          ||                              |       |
!        |          ||                              |       |
!        |          ^|================= rwD         |      hD 
!        |          |                               |       |
!        |         zwD                              |       | 
!        |          |                               |       |
!        |__________\/______________________________| ______|
!        <------------------xeD--------------------->
!


real(dp), intent(in)    :: tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD
real(dp), intent(in)    :: w,lambda,Cd,skin

real(dp), dimension(20) :: LpD,ss
real(dp)                              :: pD 
integer*4                             :: n

n = GAVER_STEHFEST_N

! Evaluate well model in Laplace Space
call Laplace_pDHorzNFB(LpD,ss,n,tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,w,lambda,Cd,skin)
! Numerically invert function from Laplace space to time
call m_invlapGS(pD,LpD,tD,n)

END FUNCTION pDHorzNFB

!---------------------------------------------------------------------------------
FUNCTION qDHorzNFB(tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,w,lambda,Cd,skin) result(qD)
!---------------------------------------------------------------------------------
! Rate for Horizontal Well in a Bounded Reservoir Squared Domain
! with cte pressure at wellbore

real(dp), intent(in)            :: tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD
real(dp), intent(in)            :: w,lambda, Cd, skin
real(dp)                        :: qD,s,u,sqrtu,pDINF

! ROOM FOR IMPROVEMENT VARIABLES BELOW SHOULD BE ALLOCATABLE
! SO n CAN BE ANY SIZE
real(dp), dimension(20)         :: LpD,LqD,ss
integer*4                       :: i,n

n = GAVER_STEHFEST_N

! Evaluate well model in Laplace Space
call Laplace_pDHorzNFB(LpD,ss,n,tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,w,lambda,Cd,skin)

! Now move from pD to qD
call pD2qD(LqD,ss,LpD,n)

! Numerically invert function from Laplace space to time
call m_invlapGS(qD,LqD,tD,n)
! We can also compute cumulative production

! Check if we got NA as answer. If that is the case it means
! we are in the infinite reD portion of the curve and as such
! we can call the infinte solution 

! ROOM FOR IMPROVEMENT NEED TO ADD INFINITE HORIZONTAL
! WELL SOLUTION SO WE CAN USE IT BELOW
!
!if(qD .NE. qD) then
!   do i=1,n
!     ! ROOM FOR IMPROVEMENT - ROOM FOR IMPROVEMENT
!     s = ss(i);
!     u=s*(w*(1-w)*s+lamda ) / ((1-w)*s+lamda);
!     sqrtu = sqrt(u);     
!     call fpDINF(pDINF,s,sqrtu,(xwD+xD),xwD);
!     LpD(i) = CdSkin(s,pDINF,Cd,skin)
!   end do
!   ! Now move from pD to qD   
!   call pD2qD(LqD,ss,LpD,n)
!   call m_invlapGS(qD,LqD,t,n)
!end if

END FUNCTION qDHorzNFB

!-------------------------------------------------------------------------------------
FUNCTION CumqDHorzNFB(tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,w,lambda,Cd,skin) result(qD)
!-------------------------------------------------------------------------------------
! Cum Rate for a Bounded Reservoir in a Squared Domain
! with cte pressure at wellbore

real(dp), intent(in)            :: tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD
real(dp), intent(in)            :: w,lambda, Cd, skin
real(dp)                        :: qD,s,u,sqrtu,pDINF

! ROOM FOR IMPROVEMENT VARIABLES BELOW SHOULD BE ALLOCATABLE
! SO n CAN BE ANY SIZE
real(dp), dimension(20)         :: LpD,LqD,ss
integer*4                       :: i,n

n = GAVER_STEHFEST_N

! Evaluate well model in Laplace Space
call Laplace_pDHorzNFB(LpD,ss,n,tD,xD,xeD,xwD,yD,yeD,ywD,zD,zwD,LD,w,lambda,Cd,skin)

! Now move from pD to CumqD
call pD2CumqD(LqD,ss,LpD,n)

! We can also compute cumulative production
! Now Integrate qD to QD - save the information in LpD
! call Integral(LpD,ss,LqD,n)

! Numerically invert function from Laplace space to time
call m_invlapGS(qD,LqD,tD,n)

END FUNCTION CumqDHorzNFB

!------------------------------------------------------------------------------------------------------
!                                                                                ,w,lambda,Cd,skin
! SUBROUTINE Laplace_pDHorzMultFracTL(pD,dpD,ss,n,xeD,yD,yeD,etaOD,etaFD,CRD,CFD,dpm,w,lambda,Cd,skin)
SUBROUTINE Laplace_pDHorzMultFracTL(pD,ss,n,xeD,yD,yeD,etaOD,etaFD,CRD,CFD,dpm,w,lambda,Cd,skin)
!------------------------------------------------------------------------------------------------------
! Fractured Horizontal Wells with Trilinear model simplification
! See SPE 125043 - Practial Solutions for Pressure-Transient 
! Responses of Fractured Horizontal Wells in Unconventional Shale
! Reservoirs

real(dp), intent(out), dimension(n):: pD
! real(dp), intent(out), dimension(n):: dpD
real(dp), intent(in), dimension(n) :: ss
real(dp), intent(in)               :: xeD,yD,yeD,etaOD,etaFD,CRD,CFD
CHARACTER(LEN=7), intent(in)       :: dpm
real(dp), intent(in)               :: w,lambda, Cd, skin
integer(kind=4), intent(in)        :: n

real(dp)                           :: s,u
integer(kind=4)                    :: i
real(dp),              dimension(n):: fs

! Intermedia variables
real(dp)                           :: sqrta,alpha_0,alpha_F,beta_0,beta_F,pFD

call select_dual_porosity_model(fs,ss,n,dpm,w,lambda)

do i=1,n
  s = ss(i);
  u = s*fs(i);

  ! Equation 27 / equation 3.46
  sqrta = sqrt(s/etaOD);
  beta_0=sqrta*tanh(sqrta*(xeD-1));

  ! Equation 29 / equation 3.50
  alpha_0 = beta_0/(CRD*yeD)+u;

  ! Equation 36 / equation 3.74
  sqrta=sqrt(alpha_0);
  ! yD = -wD/2;
  beta_F=sqrta*tanh(sqrta*(yeD-yD));

  ! Equation 37 / equation 3.78
  alpha_F=2*beta_F/CFD+s/etaFD;

  ! Equation 40 / equation 3.95
  ! Dimensionless pressure solution for the hydraulic
  ! fracture is obtained as
  ! Wellbore pressure solution xD = 0
  sqrta = sqrt(alpha_F);
  pFD = tanh(sqrta);
  pFD = pi/(CFD*s*sqrta*pFD);

  ! Will add wellbore storage and skin later using function CdSkin
  ! pFD = pFD + Sc/s;
  ! Include wellbore storage
  ! pWD=pFD/(1+CD*s^2*pFD);

  ! Derivative
  ! dpWD=s*pWD;

  ! Add wellbore storage and skin
  pD(i) = CdSkin(s,pFD,Cd,skin)
  ! dpD(i)=Derivative(s,F)
  ! dpD(i)= pD(i)*s;  
end do

END SUBROUTINE

!--------------------------------------------------------------------------------------------
SUBROUTINE pDHorzMultFracTL(pD,dpD,tD,xeD,yD,yeD,etaOD,etaFD,CRD,CFD,dpm,w,lambda,Cd,skin)
!--------------------------------------------------------------------------------------------
real(dp), intent(in)               :: tD,xeD,yD,yeD,etaOD,etaFD,CRD,CFD
CHARACTER(LEN=7), intent(in)       :: dpm
real(dp), intent(in)               :: w,lambda, Cd, skin

real(dp), dimension(20) :: LpD,LdpD,ss
real(dp), intent(out)   :: pD 
real(dp), intent(out)   :: dpD
integer*4               :: n
n = GAVER_STEHFEST_N

! Find the Laplace s evaluation points for a given tD
call lsepGS(ss, tD, n)

! Evaluate well model in Laplace Space
call Laplace_pDHorzMultFracTL(LpD,ss,n,xeD,yD,yeD,etaOD,etaFD,CRD,CFD,dpm,w,lambda,Cd,skin)

! Now move from pD to dpD
call pD2dpD(LdpD,ss,LpD,n)

! Numerically invert function from Laplace space to time
call m_invlapGS(pD ,LpD ,tD,n)
call m_invlapGS(dpD,LdpD,tD,n)

!    m_invlapGSMultOut(ft,dft,F,dF,t,n)
!    m_invlapGSMultOut (ft,dft,F,  dF,  t, n)
!call m_invlapGSMultOut(pD,dpD,LpD,LdpD,tD,n)

END SUBROUTINE


!--------------------------------------------------------------------------------------------
SUBROUTINE qDHorzMultFracTL(qD,CumqD,tD,xeD,yD,yeD,etaOD,etaFD,CRD,CFD,dpm,w,lambda,Cd,skin)
!--------------------------------------------------------------------------------------------
real(dp), intent(in)               :: tD,xeD,yD,yeD,etaOD,etaFD,CRD,CFD
CHARACTER(LEN=7), intent(in)       :: dpm
real(dp), intent(in)               :: w,lambda, Cd, skin

real(dp), dimension(20) :: LpD,LqD,LCumqD,ss
real(dp), intent(out)   :: qD 
real(dp), intent(out)   :: CumqD
integer*4               :: n
n = GAVER_STEHFEST_N

! Find the Laplace s evaluation points for a given tD
call lsepGS(ss, tD, n)

! Evaluate well model in Laplace Space
call Laplace_pDHorzMultFracTL(LpD,ss,n,xeD,yD,yeD,etaOD,etaFD,CRD,CFD,dpm,w,lambda,Cd,skin)

! Move from pD to qD and CumqD
! Now move from pD to qD
call pD2qD(LqD,ss,LpD,n)
! Now move from pD to CumqD
call pD2CumqD(LCumqD,ss,LpD,n)


! Numerically invert function from Laplace space to time
call m_invlapGS(qD   ,LqD   ,tD,n)
call m_invlapGS(CumqD,LCumqD,tD,n)

!    m_invlapGSMultOut(ft,dft,F,dF,t,n)
!    m_invlapGSMultOut (ft,dft,F,  dF,  t, n)
!call m_invlapGSMultOut(pD,dpD,LpD,LdpD,tD,n)

END SUBROUTINE



!------------------------------------------------------------
SUBROUTINE select_dual_porosity_model(fs,ss,n,dpm,w,lambda)
!------------------------------------------------------------
! This subroutine select the type of dual porosity model
! to be used, avalible models are 
! homo: Homogeneous
! pseudoss: Pseudo Steady State. Warrent and Root
! trans   : Transient

CHARACTER(LEN=7), intent(in)       :: dpm
real(dp), intent(in), dimension(n) :: ss
integer(kind=4), intent(in)        :: n
real(dp), intent(in)               :: w,lambda
real(dp), intent(out), dimension(n):: fs
integer(kind=4)                    :: i

! Equation 25
select case (dpm)
    case ("homo")
        ! Homogenous reservoir
        fs=1;
    case ("pseudss")
        do i=1,n        
           ! Pseudosteady state dual-porosity inner reservoir
           fs(i)=(ss(i)*w*(1-w)+lambda ) / ((1-w)*ss(i)+lambda);
        end do  
    case ("trans")
        do i=1,n
           fs(i)=1+sqrt(lambda*w/(3*ss(i)))*tanh(sqrt(3*ss(i)*w/lambda));
        end do
    case default
        ! Homogenous reservoir
        fs=1;
end select

END SUBROUTINE


END MODULE well_models
